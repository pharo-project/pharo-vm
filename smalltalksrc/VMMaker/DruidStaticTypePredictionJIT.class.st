Class {
	#name : #DruidStaticTypePredictionJIT,
	#superclass : #DruidJIT,
	#category : #'VMMaker-JIT'
}

{ #category : #'class initialization' }
DruidStaticTypePredictionJIT class >> bytecodeTable [

	<generated>
	^ {
		  { 1. 0. 0. #gen_PushReceiverVariableBytecode0.
		  #isInstVarRef }.
		  { 1. 1. 1. #gen_PushReceiverVariableBytecode1.
		  #isInstVarRef }.
		  { 1. 2. 2. #gen_PushReceiverVariableBytecode2.
		  #isInstVarRef }.
		  { 1. 3. 3. #gen_PushReceiverVariableBytecode3.
		  #isInstVarRef }.
		  { 1. 4. 4. #gen_PushReceiverVariableBytecode4.
		  #isInstVarRef }.
		  { 1. 5. 5. #gen_PushReceiverVariableBytecode5.
		  #isInstVarRef }.
		  { 1. 6. 6. #gen_PushReceiverVariableBytecode6.
		  #isInstVarRef }.
		  { 1. 7. 7. #gen_PushReceiverVariableBytecode7.
		  #isInstVarRef }.
		  { 1. 8. 8. #gen_PushReceiverVariableBytecode8.
		  #isInstVarRef }.
		  { 1. 9. 9. #gen_PushReceiverVariableBytecode9.
		  #isInstVarRef }.
		  { 1. 10. 10. #gen_PushReceiverVariableBytecode10.
		  #isInstVarRef }.
		  { 1. 11. 11. #gen_PushReceiverVariableBytecode11.
		  #isInstVarRef }.
		  { 1. 12. 12. #gen_PushReceiverVariableBytecode12.
		  #isInstVarRef }.
		  { 1. 13. 13. #gen_PushReceiverVariableBytecode13.
		  #isInstVarRef }.
		  { 1. 14. 14. #gen_PushReceiverVariableBytecode14.
		  #isInstVarRef }.
		  { 1. 15. 15. #gen_PushReceiverVariableBytecode15.
		  #isInstVarRef }.
		  { 1. 16. 16. #gen_PushLiteralVariable16CasesBytecode0.
		  #needsFrameNever:. 1 }.
		  { 1. 17. 17. #gen_PushLiteralVariable16CasesBytecode1.
		  #needsFrameNever:. 1 }.
		  { 1. 18. 18. #gen_PushLiteralVariable16CasesBytecode2.
		  #needsFrameNever:. 1 }.
		  { 1. 19. 19. #gen_PushLiteralVariable16CasesBytecode3.
		  #needsFrameNever:. 1 }.
		  { 1. 20. 20. #gen_PushLiteralVariable16CasesBytecode4.
		  #needsFrameNever:. 1 }.
		  { 1. 21. 21. #gen_PushLiteralVariable16CasesBytecode5.
		  #needsFrameNever:. 1 }.
		  { 1. 22. 22. #gen_PushLiteralVariable16CasesBytecode6.
		  #needsFrameNever:. 1 }.
		  { 1. 23. 23. #gen_PushLiteralVariable16CasesBytecode7.
		  #needsFrameNever:. 1 }.
		  { 1. 24. 24. #gen_PushLiteralVariable16CasesBytecode8.
		  #needsFrameNever:. 1 }.
		  { 1. 25. 25. #gen_PushLiteralVariable16CasesBytecode9.
		  #needsFrameNever:. 1 }.
		  { 1. 26. 26. #gen_PushLiteralVariable16CasesBytecode10.
		  #needsFrameNever:. 1 }.
		  { 1. 27. 27. #gen_PushLiteralVariable16CasesBytecode11.
		  #needsFrameNever:. 1 }.
		  { 1. 28. 28. #gen_PushLiteralVariable16CasesBytecode12.
		  #needsFrameNever:. 1 }.
		  { 1. 29. 29. #gen_PushLiteralVariable16CasesBytecode13.
		  #needsFrameNever:. 1 }.
		  { 1. 30. 30. #gen_PushLiteralVariable16CasesBytecode14.
		  #needsFrameNever:. 1 }.
		  { 1. 31. 31. #gen_PushLiteralVariable16CasesBytecode15.
		  #needsFrameNever:. 1 }.
		  { 1. 32. 32. #gen_PushLiteralConstantBytecode0.
		  #needsFrameNever:. 1 }.
		  { 1. 33. 33. #gen_PushLiteralConstantBytecode1.
		  #needsFrameNever:. 1 }.
		  { 1. 34. 34. #gen_PushLiteralConstantBytecode2.
		  #needsFrameNever:. 1 }.
		  { 1. 35. 35. #gen_PushLiteralConstantBytecode3.
		  #needsFrameNever:. 1 }.
		  { 1. 36. 36. #gen_PushLiteralConstantBytecode4.
		  #needsFrameNever:. 1 }.
		  { 1. 37. 37. #gen_PushLiteralConstantBytecode5.
		  #needsFrameNever:. 1 }.
		  { 1. 38. 38. #gen_PushLiteralConstantBytecode6.
		  #needsFrameNever:. 1 }.
		  { 1. 39. 39. #gen_PushLiteralConstantBytecode7.
		  #needsFrameNever:. 1 }.
		  { 1. 40. 40. #gen_PushLiteralConstantBytecode8.
		  #needsFrameNever:. 1 }.
		  { 1. 41. 41. #gen_PushLiteralConstantBytecode9.
		  #needsFrameNever:. 1 }.
		  { 1. 42. 42. #gen_PushLiteralConstantBytecode10.
		  #needsFrameNever:. 1 }.
		  { 1. 43. 43. #gen_PushLiteralConstantBytecode11.
		  #needsFrameNever:. 1 }.
		  { 1. 44. 44. #gen_PushLiteralConstantBytecode12.
		  #needsFrameNever:. 1 }.
		  { 1. 45. 45. #gen_PushLiteralConstantBytecode13.
		  #needsFrameNever:. 1 }.
		  { 1. 46. 46. #gen_PushLiteralConstantBytecode14.
		  #needsFrameNever:. 1 }.
		  { 1. 47. 47. #gen_PushLiteralConstantBytecode15.
		  #needsFrameNever:. 1 }.
		  { 1. 48. 48. #gen_PushLiteralConstantBytecode16.
		  #needsFrameNever:. 1 }.
		  { 1. 49. 49. #gen_PushLiteralConstantBytecode17.
		  #needsFrameNever:. 1 }.
		  { 1. 50. 50. #gen_PushLiteralConstantBytecode18.
		  #needsFrameNever:. 1 }.
		  { 1. 51. 51. #gen_PushLiteralConstantBytecode19.
		  #needsFrameNever:. 1 }.
		  { 1. 52. 52. #gen_PushLiteralConstantBytecode20.
		  #needsFrameNever:. 1 }.
		  { 1. 53. 53. #gen_PushLiteralConstantBytecode21.
		  #needsFrameNever:. 1 }.
		  { 1. 54. 54. #gen_PushLiteralConstantBytecode22.
		  #needsFrameNever:. 1 }.
		  { 1. 55. 55. #gen_PushLiteralConstantBytecode23.
		  #needsFrameNever:. 1 }.
		  { 1. 56. 56. #gen_PushLiteralConstantBytecode24.
		  #needsFrameNever:. 1 }.
		  { 1. 57. 57. #gen_PushLiteralConstantBytecode25.
		  #needsFrameNever:. 1 }.
		  { 1. 58. 58. #gen_PushLiteralConstantBytecode26.
		  #needsFrameNever:. 1 }.
		  { 1. 59. 59. #gen_PushLiteralConstantBytecode27.
		  #needsFrameNever:. 1 }.
		  { 1. 60. 60. #gen_PushLiteralConstantBytecode28.
		  #needsFrameNever:. 1 }.
		  { 1. 61. 61. #gen_PushLiteralConstantBytecode29.
		  #needsFrameNever:. 1 }.
		  { 1. 62. 62. #gen_PushLiteralConstantBytecode30.
		  #needsFrameNever:. 1 }.
		  { 1. 63. 63. #gen_PushLiteralConstantBytecode31.
		  #needsFrameNever:. 1 }.
		  { 1. 64. 64. #gen_PushTemporaryVariableBytecode0 }.
		  { 1. 65. 65. #gen_PushTemporaryVariableBytecode1 }.
		  { 1. 66. 66. #gen_PushTemporaryVariableBytecode2 }.
		  { 1. 67. 67. #gen_PushTemporaryVariableBytecode3 }.
		  { 1. 68. 68. #gen_PushTemporaryVariableBytecode4 }.
		  { 1. 69. 69. #gen_PushTemporaryVariableBytecode5 }.
		  { 1. 70. 70. #gen_PushTemporaryVariableBytecode6 }.
		  { 1. 71. 71. #gen_PushTemporaryVariableBytecode7 }.
		  { 1. 72. 72. #gen_PushTemporaryVariableBytecode8 }.
		  { 1. 73. 73. #gen_PushTemporaryVariableBytecode9 }.
		  { 1. 74. 74. #gen_PushTemporaryVariableBytecode10 }.
		  { 1. 75. 75. #gen_PushTemporaryVariableBytecode11 }.
		  { 1. 76. 76. #gen_PushReceiverBytecode }.
		  { 1. 77. 77. #gen_PushConstantTrueBytecode.
		  #needsFrameNever:. 1 }.
		  { 1. 78. 78. #gen_PushConstantFalseBytecode.
		  #needsFrameNever:. 1 }.
		  { 1. 79. 79. #gen_PushConstantNilBytecode.
		  #needsFrameNever:. 1 }.
		  { 1. 80. 80. #gen_PushConstantZeroBytecode.
		  #needsFrameNever:. 1 }.
		  { 1. 81. 81. #gen_PushConstantOneBytecode.
		  #needsFrameNever:. 1 }.
		  { 1. 82. 82. #unknownBytecode }.
		  { 1. 83. 83. #gen_DuplicateTopBytecode. #needsFrameNever:.
		  1 }.
		  { 1. 84. 84. #unknownBytecode }.
		  { 1. 85. 85. #unknownBytecode }.
		  { 1. 86. 86. #unknownBytecode }.
		  { 1. 87. 87. #unknownBytecode }.
		  { 1. 88. 88. #gen_ReturnReceiver. #return. #isMappedInBlock.
		  #needsFrameIfInBlock:. 0 }.
		  { 1. 89. 89. #gen_ReturnTrue. #return. #isMappedInBlock.
		  #needsFrameIfInBlock:. 0 }.
		  { 1. 90. 90. #gen_ReturnFalse. #return. #isMappedInBlock.
		  #needsFrameIfInBlock:. 0 }.
		  { 1. 91. 91. #gen_ReturnNil. #return. #isMappedInBlock.
		  #needsFrameIfInBlock:. 0 }.
		  { 1. 92. 92. #gen_ReturnTopFromMethod. #return. #isMappedInBlock.
		  #needsFrameIfInBlock:.  -1 }.
		  { 1. 93. 93. #gen_ReturnNilFromBlock. #return. #needsFrameNever:.
		   -1 }.
		  { 1. 94. 94. #gen_ReturnTopFromBlock. #return. #needsFrameNever:.
		   -1 }.
		  { 1. 95. 95. #gen_ExtNopBytecode. #needsFrameNever:.
		  0 }.
		  { 1. 96. 96. #gen_BytecodePrimAdd. #isMapped }.
		  { 1. 97. 97. #gen_BytecodePrimSubtract. #isMapped }.
		  { 1. 98. 98. #gen_BytecodePrimLessThanSistaV1.
		  #isMapped }.
		  { 1. 99. 99. #gen_BytecodePrimGreaterThanSistaV1.
		  #isMapped }.
		  { 1. 100. 100. #gen_BytecodePrimLessOrEqualSistaV1.
		  #isMapped }.
		  { 1. 101. 101. #gen_BytecodePrimGreaterOrEqualSistaV1.
		  #isMapped }.
		  { 1. 102. 102. #gen_BytecodePrimEqualSistaV1.
		  #isMapped }.
		  { 1. 103. 103. #gen_BytecodePrimNotEqualSistaV1.
		  #isMapped }.
		  { 1. 104. 104. #gen_BytecodePrimMultiply. #isMapped }.
		  { 1. 105. 105. #gen_BytecodePrimDivide. #isMapped }.
		  { 1. 106. 106. #gen_BytecodePrimMod. #isMapped }.
		  { 1. 107. 107. #gen_BytecodePrimMakePoint.
		  #isMapped }.
		  { 1. 108. 108. #gen_BytecodePrimBitShift. #isMapped }.
		  { 1. 109. 109. #gen_BytecodePrimDiv. #isMapped }.
		  { 1. 110. 110. #gen_BytecodePrimBitAnd. #isMapped }.
		  { 1. 111. 111. #gen_BytecodePrimBitOr. #isMapped }.
		  { 1. 112. 112. #gen_BytecodePrimAt. #isMapped }.
		  { 1. 113. 113. #gen_BytecodePrimAtPut. #isMapped }.
		  { 1. 114. 114. #gen_BytecodePrimSize. #isMapped }.
		  { 1. 115. 115. #gen_BytecodePrimNext. #isMapped }.
		  { 1. 116. 116. #gen_BytecodePrimNextPut. #isMapped }.
		  { 1. 117. 117. #gen_BytecodePrimAtEnd. #isMapped }.
		  { 1. 118. 118. #gen_BytecodePrimIdenticalSistaV1 }.
		  { 1. 119. 119. #unknownBytecode }.
		  { 1. 120. 120. #gen_BytecodePrimNotIdenticalSistaV1 }.
		  { 1. 121. 121. #gen_BytecodePrimValue. #isMapped }.
		  { 1. 122. 122. #gen_BytecodePrimValueWithArg.
		  #isMapped }.
		  { 1. 123. 123. #gen_BytecodePrimDo. #isMapped }.
		  { 1. 124. 124. #gen_BytecodePrimNew. #isMapped }.
		  { 1. 125. 125. #gen_BytecodePrimNewWithArg.
		  #isMapped }.
		  { 1. 126. 126. #gen_BytecodePrimPointX. #isMapped }.
		  { 1. 127. 127. #gen_BytecodePrimPointY. #isMapped }.
		  { 1. 128. 128. #gen_SendLiteralSelector0ArgsBytecode0.
		  #isMapped }.
		  { 1. 129. 129. #gen_SendLiteralSelector0ArgsBytecode1.
		  #isMapped }.
		  { 1. 130. 130. #gen_SendLiteralSelector0ArgsBytecode2.
		  #isMapped }.
		  { 1. 131. 131. #gen_SendLiteralSelector0ArgsBytecode3.
		  #isMapped }.
		  { 1. 132. 132. #gen_SendLiteralSelector0ArgsBytecode4.
		  #isMapped }.
		  { 1. 133. 133. #gen_SendLiteralSelector0ArgsBytecode5.
		  #isMapped }.
		  { 1. 134. 134. #gen_SendLiteralSelector0ArgsBytecode6.
		  #isMapped }.
		  { 1. 135. 135. #gen_SendLiteralSelector0ArgsBytecode7.
		  #isMapped }.
		  { 1. 136. 136. #gen_SendLiteralSelector0ArgsBytecode8.
		  #isMapped }.
		  { 1. 137. 137. #gen_SendLiteralSelector0ArgsBytecode9.
		  #isMapped }.
		  { 1. 138. 138. #gen_SendLiteralSelector0ArgsBytecode10.
		  #isMapped }.
		  { 1. 139. 139. #gen_SendLiteralSelector0ArgsBytecode11.
		  #isMapped }.
		  { 1. 140. 140. #gen_SendLiteralSelector0ArgsBytecode12.
		  #isMapped }.
		  { 1. 141. 141. #gen_SendLiteralSelector0ArgsBytecode13.
		  #isMapped }.
		  { 1. 142. 142. #gen_SendLiteralSelector0ArgsBytecode14.
		  #isMapped }.
		  { 1. 143. 143. #gen_SendLiteralSelector0ArgsBytecode15.
		  #isMapped }.
		  { 1. 144. 144. #gen_SendLiteralSelector1ArgBytecode0.
		  #isMapped }.
		  { 1. 145. 145. #gen_SendLiteralSelector1ArgBytecode1.
		  #isMapped }.
		  { 1. 146. 146. #gen_SendLiteralSelector1ArgBytecode2.
		  #isMapped }.
		  { 1. 147. 147. #gen_SendLiteralSelector1ArgBytecode3.
		  #isMapped }.
		  { 1. 148. 148. #gen_SendLiteralSelector1ArgBytecode4.
		  #isMapped }.
		  { 1. 149. 149. #gen_SendLiteralSelector1ArgBytecode5.
		  #isMapped }.
		  { 1. 150. 150. #gen_SendLiteralSelector1ArgBytecode6.
		  #isMapped }.
		  { 1. 151. 151. #gen_SendLiteralSelector1ArgBytecode7.
		  #isMapped }.
		  { 1. 152. 152. #gen_SendLiteralSelector1ArgBytecode8.
		  #isMapped }.
		  { 1. 153. 153. #gen_SendLiteralSelector1ArgBytecode9.
		  #isMapped }.
		  { 1. 154. 154. #gen_SendLiteralSelector1ArgBytecode10.
		  #isMapped }.
		  { 1. 155. 155. #gen_SendLiteralSelector1ArgBytecode11.
		  #isMapped }.
		  { 1. 156. 156. #gen_SendLiteralSelector1ArgBytecode12.
		  #isMapped }.
		  { 1. 157. 157. #gen_SendLiteralSelector1ArgBytecode13.
		  #isMapped }.
		  { 1. 158. 158. #gen_SendLiteralSelector1ArgBytecode14.
		  #isMapped }.
		  { 1. 159. 159. #gen_SendLiteralSelector1ArgBytecode15.
		  #isMapped }.
		  { 1. 160. 160. #gen_SendLiteralSelector2ArgsBytecode0.
		  #isMapped }.
		  { 1. 161. 161. #gen_SendLiteralSelector2ArgsBytecode1.
		  #isMapped }.
		  { 1. 162. 162. #gen_SendLiteralSelector2ArgsBytecode2.
		  #isMapped }.
		  { 1. 163. 163. #gen_SendLiteralSelector2ArgsBytecode3.
		  #isMapped }.
		  { 1. 164. 164. #gen_SendLiteralSelector2ArgsBytecode4.
		  #isMapped }.
		  { 1. 165. 165. #gen_SendLiteralSelector2ArgsBytecode5.
		  #isMapped }.
		  { 1. 166. 166. #gen_SendLiteralSelector2ArgsBytecode6.
		  #isMapped }.
		  { 1. 167. 167. #gen_SendLiteralSelector2ArgsBytecode7.
		  #isMapped }.
		  { 1. 168. 168. #gen_SendLiteralSelector2ArgsBytecode8.
		  #isMapped }.
		  { 1. 169. 169. #gen_SendLiteralSelector2ArgsBytecode9.
		  #isMapped }.
		  { 1. 170. 170. #gen_SendLiteralSelector2ArgsBytecode10.
		  #isMapped }.
		  { 1. 171. 171. #gen_SendLiteralSelector2ArgsBytecode11.
		  #isMapped }.
		  { 1. 172. 172. #gen_SendLiteralSelector2ArgsBytecode12.
		  #isMapped }.
		  { 1. 173. 173. #gen_SendLiteralSelector2ArgsBytecode13.
		  #isMapped }.
		  { 1. 174. 174. #gen_SendLiteralSelector2ArgsBytecode14.
		  #isMapped }.
		  { 1. 175. 175. #gen_SendLiteralSelector2ArgsBytecode15.
		  #isMapped }.
		  { 1. 176. 176. #gen_ShortUnconditionalJump0.
		  #branch. #v3:ShortForward:Branch:Distance: }.
		  { 1. 177. 177. #gen_ShortUnconditionalJump1.
		  #branch. #v3:ShortForward:Branch:Distance: }.
		  { 1. 178. 178. #gen_ShortUnconditionalJump2.
		  #branch. #v3:ShortForward:Branch:Distance: }.
		  { 1. 179. 179. #gen_ShortUnconditionalJump3.
		  #branch. #v3:ShortForward:Branch:Distance: }.
		  { 1. 180. 180. #gen_ShortUnconditionalJump4.
		  #branch. #v3:ShortForward:Branch:Distance: }.
		  { 1. 181. 181. #gen_ShortUnconditionalJump5.
		  #branch. #v3:ShortForward:Branch:Distance: }.
		  { 1. 182. 182. #gen_ShortUnconditionalJump6.
		  #branch. #v3:ShortForward:Branch:Distance: }.
		  { 1. 183. 183. #gen_ShortUnconditionalJump7.
		  #branch. #v3:ShortForward:Branch:Distance: }.
		  { 1. 184. 184. #gen_ShortConditionalJumpTrue0.
		  #branch. #isBranchTrue. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 185. 185. #gen_ShortConditionalJumpTrue1.
		  #branch. #isBranchTrue. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 186. 186. #gen_ShortConditionalJumpTrue2.
		  #branch. #isBranchTrue. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 187. 187. #gen_ShortConditionalJumpTrue3.
		  #branch. #isBranchTrue. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 188. 188. #gen_ShortConditionalJumpTrue4.
		  #branch. #isBranchTrue. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 189. 189. #gen_ShortConditionalJumpTrue5.
		  #branch. #isBranchTrue. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 190. 190. #gen_ShortConditionalJumpTrue6.
		  #branch. #isBranchTrue. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 191. 191. #gen_ShortConditionalJumpTrue7.
		  #branch. #isBranchTrue. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 192. 192. #gen_ShortConditionalJumpFalse0.
		  #branch. #isBranchFalse. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 193. 193. #gen_ShortConditionalJumpFalse1.
		  #branch. #isBranchFalse. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 194. 194. #gen_ShortConditionalJumpFalse2.
		  #branch. #isBranchFalse. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 195. 195. #gen_ShortConditionalJumpFalse3.
		  #branch. #isBranchFalse. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 196. 196. #gen_ShortConditionalJumpFalse4.
		  #branch. #isBranchFalse. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 197. 197. #gen_ShortConditionalJumpFalse5.
		  #branch. #isBranchFalse. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 198. 198. #gen_ShortConditionalJumpFalse6.
		  #branch. #isBranchFalse. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 199. 199. #gen_ShortConditionalJumpFalse7.
		  #branch. #isBranchFalse. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 200. 200. #gen_StoreAndPopReceiverVariableBytecode0.
		  #isInstVarRef. #isMappedIfImmutability. #needsFrameIfImmutability:.
		   -1 }.
		  { 1. 201. 201. #gen_StoreAndPopReceiverVariableBytecode1.
		  #isInstVarRef. #isMappedIfImmutability. #needsFrameIfImmutability:.
		   -1 }.
		  { 1. 202. 202. #gen_StoreAndPopReceiverVariableBytecode2.
		  #isInstVarRef. #isMappedIfImmutability. #needsFrameIfImmutability:.
		   -1 }.
		  { 1. 203. 203. #gen_StoreAndPopReceiverVariableBytecode3.
		  #isInstVarRef. #isMappedIfImmutability. #needsFrameIfImmutability:.
		   -1 }.
		  { 1. 204. 204. #gen_StoreAndPopReceiverVariableBytecode4.
		  #isInstVarRef. #isMappedIfImmutability. #needsFrameIfImmutability:.
		   -1 }.
		  { 1. 205. 205. #gen_StoreAndPopReceiverVariableBytecode5.
		  #isInstVarRef. #isMappedIfImmutability. #needsFrameIfImmutability:.
		   -1 }.
		  { 1. 206. 206. #gen_StoreAndPopReceiverVariableBytecode6.
		  #isInstVarRef. #isMappedIfImmutability. #needsFrameIfImmutability:.
		   -1 }.
		  { 1. 207. 207. #gen_StoreAndPopReceiverVariableBytecode7.
		  #isInstVarRef. #isMappedIfImmutability. #needsFrameIfImmutability:.
		   -1 }.
		  { 1. 208. 208. #gen_StoreAndPopTemporaryVariableBytecode0 }.
		  { 1. 209. 209. #gen_StoreAndPopTemporaryVariableBytecode1 }.
		  { 1. 210. 210. #gen_StoreAndPopTemporaryVariableBytecode2 }.
		  { 1. 211. 211. #gen_StoreAndPopTemporaryVariableBytecode3 }.
		  { 1. 212. 212. #gen_StoreAndPopTemporaryVariableBytecode4 }.
		  { 1. 213. 213. #gen_StoreAndPopTemporaryVariableBytecode5 }.
		  { 1. 214. 214. #gen_StoreAndPopTemporaryVariableBytecode6 }.
		  { 1. 215. 215. #gen_StoreAndPopTemporaryVariableBytecode7 }.
		  { 1. 216. 216. #gen_PopStackBytecode. #needsFrameNever:.
		   -1 }.
		  { 1. 217. 217. #unknownBytecode }.
		  { 1. 218. 218. #unknownBytecode }.
		  { 1. 219. 219. #unknownBytecode }.
		  { 1. 220. 220. #unknownBytecode }.
		  { 1. 221. 221. #unknownBytecode }.
		  { 1. 222. 222. #unknownBytecode }.
		  { 1. 223. 223. #unknownBytecode }.
		  { 2. 224. 224. #gen_ExtABytecode. #extension }.
		  { 2. 225. 225. #gen_ExtBBytecode. #extension }.
		  { 2. 226. 226. #gen_ExtPushReceiverVariableBytecode.
		  #isInstVarRef. #isMappedIfImmutability }.
		  { 2. 227. 227. #gen_ExtPushLiteralVariableBytecode.
		  #needsFrameNever:. 1 }.
		  { 2. 228. 228. #gen_ExtPushLiteralBytecode.
		  #needsFrameNever:. 1 }.
		  { 2. 229. 229. #gen_LongPushTemporaryVariableBytecode }.
		  { 2. 230. 230. #unknownBytecode }.
		  { 2. 231. 231. #gen_PushNewArrayBytecode }.
		  { 2. 232. 232. #gen_ExtPushIntegerBytecode.
		  #needsFrameNever:. 1 }.
		  { 2. 233. 233. #gen_ExtPushCharacterBytecode.
		  #needsFrameNever:. 1 }.
		  { 2. 234. 234. #gen_ExtSendBytecode. #isMapped }.
		  { 2. 235. 235. #gen_ExtSendSuperBytecode. #isMapped }.
		  { 2. 236. 236. #unknownBytecode }.
		  { 2. 237. 237. #gen_ExtUnconditionalJump. #branch. #isMapped.
		  #v4:Long:Branch:Distance: }.
		  { 2. 238. 238. #gen_ExtJumpIfTrue. #branch. #isBranchTrue.
		  #isMapped. #v4:Long:Branch:Distance: }.
		  { 2. 239. 239. #gen_ExtJumpIfFalse. #branch. #isBranchFalse.
		  #isMapped. #v4:Long:Branch:Distance: }.
		  { 2. 240. 240. #gen_ExtStoreAndPopReceiverVariableBytecode.
		  #isInstVarRef. #isMappedIfImmutability }.
		  { 2. 241. 241. #gen_ExtStoreAndPopLiteralVariableBytecode.
		  #isMappedIfImmutability }.
		  { 2. 242. 242. #gen_LongStoreAndPopTemporaryVariableBytecode }.
		  { 2. 243. 243. #gen_ExtStoreReceiverVariableBytecode.
		  #isInstVarRef. #isMappedIfImmutability. #needsFrameIfImmutability:.
		  0 }.
		  { 2. 244. 244. #gen_ExtStoreLiteralVariableBytecode.
		  #isMappedIfImmutability }.
		  { 2. 245. 245. #gen_LongStoreTemporaryVariableBytecode }.
		  { 2. 246. 246. #unknownBytecode }.
		  { 2. 247. 247. #unknownBytecode }.
		  { 3. 248. 248. #gen_CallPrimitiveBytecode }.
		  { 3. 249. 249. #gen_ExtPushFullClosureBytecode }.
		  { 3. 250. 250. #unknownBytecode }.
		  { 3. 251. 251. #gen_PushRemoteTempLongBytecode }.
		  { 3. 252. 252. #gen_StoreRemoteTempLongBytecode.
		  #isMappedIfImmutability. #needsFrameIfImmutability:.
		  0 }.
		  { 3. 253. 253. #gen_StoreAndPopRemoteTempLongBytecode.
		  #isMappedIfImmutability. #needsFrameIfImmutability:.
		   -1 }.
		  { 3. 254. 254. #unknownBytecode }.
		  { 3. 255. 255. #unknownBytecode } }
]

{ #category : #'class initialization' }
DruidStaticTypePredictionJIT class >> initializeBytecodeTableForSistaV1 [

	<generated>
	numPushNilsFunction := #sistaV1:Num:Push:Nils:.
	pushNilSizeFunction := #sistaV1PushNilSize:numInitialNils:.
	BytecodeSetHasDirectedSuperSend := true.
	BytecodeSetHasExtensions := true.
	FirstSpecialSelector := 96.
	NumSpecialSelectors := 32.
	self generatorTableFrom: self bytecodeTable
]

{ #category : #'class initialization' }
DruidStaticTypePredictionJIT class >> initializePrimitiveTable [

	<generated>
	MaxCompiledPrimitiveIndex := 550.
	primitiveTable := CArrayAccessor on:
		                  (Array new: MaxCompiledPrimitiveIndex + 1).
	self table: primitiveTable from: self primitiveTableArray.
	^ primitiveTable
]

{ #category : #'class initialization' }
DruidStaticTypePredictionJIT class >> primitiveTableArray [

	<generated>
	^ {
		  { 1. #gen_PrimitiveAdd. 1 }.
		  { 2. #gen_PrimitiveSubtract. 1 }.
		  { 3. #gen_PrimitiveLessThan. 1 }.
		  { 4. #gen_PrimitiveGreaterThan. 1 }.
		  { 5. #gen_PrimitiveLessOrEqual. 1 }.
		  { 6. #gen_PrimitiveGreaterOrEqual. 1 }.
		  { 7. #gen_PrimitiveEqual. 1 }.
		  { 8. #gen_PrimitiveNotEqual. 1 }.
		  { 9. #gen_PrimitiveMultiply. 1 }.
		  { 10. #gen_PrimitiveDivide. 1 }.
		  { 11. #gen_PrimitiveMod. 1 }.
		  { 12. #gen_PrimitiveDiv. 1 }.
		  { 13. #gen_PrimitiveQuo. 1 }.
		  { 14. #gen_PrimitiveBitAnd. 1 }.
		  { 15. #gen_PrimitiveBitOr. 1 }.
		  { 16. #gen_PrimitiveBitXor. 1 }.
		  { 17. #gen_PrimitiveBitShift. 1 }.
		  { 40. #gen_PrimitiveAsFloat. 0 }.
		  { 41. #gen_PrimitiveFloatAdd. 1 }.
		  { 42. #gen_PrimitiveFloatSubtract. 1 }.
		  { 43. #gen_PrimitiveFloatLessThan. 1 }.
		  { 44. #gen_PrimitiveFloatGreaterThan.
		  1 }.
		  { 45. #gen_PrimitiveFloatLessOrEqual.
		  1 }.
		  { 46. #gen_PrimitiveFloatGreaterOrEqual.
		  1 }.
		  { 47. #gen_PrimitiveFloatEqual. 1 }.
		  { 48. #gen_PrimitiveFloatNotEqual. 1 }.
		  { 49. #gen_PrimitiveFloatMultiply. 1 }.
		  { 60. #gen_PrimitiveAt. 1 }.
		  { 61. #gen_PrimitiveAtPut. 2 }.
		  { 62. #gen_PrimitiveSize. 0 }.
		  { 63. #gen_PrimitiveStringAt. 1 }.
		  { 64. #gen_PrimitiveStringAtPut. 2 }.
		  { 70. #gen_PrimitiveNew. 0 }.
		  { 71. #gen_PrimitiveNewWithArg. 1 }.
		  { 73. #genNonImplementedPrimitive.  -1. #maycallback }.
		  { 75. #gen_PrimitiveIdentityHash. 0 }.
		  { 110. #gen_PrimitiveIdentical. 1 }.
		  { 111. #gen_PrimitiveClass }.
		  { 117. #genNonImplementedPrimitive.  -1. #maycallback }.
		  { 120. #genNonImplementedPrimitive.  -1. #maycallback }.
		  { 148. #genNonImplementedPrimitive.  -1. #maycallback }.
		  { 160. #genNonImplementedPrimitive.  -1. #maycallback }.
		  { 169. #gen_PrimitiveNotIdentical. 1 }.
		  { 170. #gen_PrimitiveAsCharacter }.
		  { 171. #gen_PrimitiveImmediateAsInteger }.
		  { 173. #genNonImplementedPrimitive.  -1. #maycallback }.
		  { 207. #gen_PrimitiveFullClosureValue }.
		  { 209. #gen_PrimitiveFullClosureValueNoContextSwitch }.
		  { 216. #genNonImplementedPrimitive.  -1. #maycallback }.
		  { 541. #gen_PrimitiveSmallFloatAdd. 1 }.
		  { 542. #gen_PrimitiveSmallFloatSubtract.
		  1 }.
		  { 543. #gen_PrimitiveSmallFloatLessThan.
		  1 }.
		  { 544. #gen_PrimitiveSmallFloatGreaterThan.
		  1 }.
		  { 545. #gen_PrimitiveSmallFloatLessOrEqual.
		  1 }.
		  { 546. #gen_PrimitiveSmallFloatGreaterOrEqual.
		  1 }.
		  { 547. #gen_PrimitiveSmallFloatEqual. 1 }.
		  { 548. #gen_PrimitiveSmallFloatNotEqual.
		  1 }.
		  { 549. #gen_PrimitiveSmallFloatMultiply.
		  1 }.
		  { 550. #gen_PrimitiveSmallFloatDivide.
		  1 } }
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimAdd [
	"AutoGenerated by Druid"

	| t0 jump3 jump1 t1 currentBlock jump2 live t2 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndR: t1 R: t2.
	self TstCq: 1 R: t2.
	jump1 := self JumpZero: 0.
	self AddCq:  -1 R: t0.
	self AddR: t1 R: t0.
	jump2 := self JumpOverflow: 0.
	self ssUnspillStackSlotAt: 0.
	self ssUnspillStackSlotAt: 1.
	self MoveR: t0 R: t2.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -1
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self MoveR: ReceiverResultReg R: t2.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: t2.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimAt [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -17
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimAtEnd [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: -22
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimAtPut [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: -18
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimBitAnd [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -15
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimBitOr [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -16
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimBitShift [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -13
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimDiv [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -14
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimDivide [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -10
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimDo [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -28
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimEqualSistaV1 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -7
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimGreaterOrEqualSistaV1 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -6
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimGreaterThanSistaV1 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -4
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimIdenticalSistaV1 [
	"AutoGenerated by Druid"

	| jump1 s57 s54 t1 jump6 jump3 b496 currentBlock t3 t0 b500 jump2 jump5 live t2 jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	t3 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t3).
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b500 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b500.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t2 R: t0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t2.
	b496 := self Label.
	self MoveR: t2 R: t3.
	self AndCq: 7 R: t3.
	self CmpCq: 0 R: t3.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t3.
	self AndCq: 16r3FFFF7 R: t3.
	self CmpCq: 0 R: t3.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t3.
	self MoveR: t3 R: t2.
	jump6 := self Jump: b496.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t2 R: t3.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	self MoveR: t1 R: t3.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.

	self ssUnspillTopStackSlots: 2.
	self ssPop: 2 popSpilled: false.

	self CmpR: t3 R: t0.
	jump3 := self JumpNonZero: 0.
	s54 := objectMemory trueObject.
	self MoveCq: s54 R: t3.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s57 := objectMemory falseObject.
	self MoveCq: s57 R: t3.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 0 R: t3.
	jump2 := self JumpZero: 0.
	self ssPushRegister: t3.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimLessOrEqualSistaV1 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -5
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimLessThanSistaV1 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -3
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimMakePoint [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -12
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimMod [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -11
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimMultiply [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -9
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimNew [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: -29
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimNewWithArg [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -30
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimNext [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: -20
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimNextPut [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -21
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimNotEqualSistaV1 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -8
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimNotIdenticalSistaV1 [
	"AutoGenerated by Druid"

	| jump1 s57 s54 t1 jump6 jump3 b496 currentBlock t3 t0 b500 jump2 jump5 live t2 jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	t3 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t3).
	(self ssValue: 1) copyToReg: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b500 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b500.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t2 R: t0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t2.
	b496 := self Label.
	self MoveR: t2 R: t3.
	self AndCq: 7 R: t3.
	self CmpCq: 0 R: t3.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t3.
	self AndCq: 16r3FFFF7 R: t3.
	self CmpCq: 0 R: t3.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t3.
	self MoveR: t3 R: t2.
	jump6 := self Jump: b496.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t2 R: t3.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	self MoveR: t1 R: t3.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	
	self ssUnspillTopStackSlots: 2.
	self ssPop: 2 popSpilled: false.
	
	self CmpR: t3 R: t0.
	jump3 := self JumpZero: 0.
	s54 := objectMemory trueObject.
	self MoveCq: s54 R: t3.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s57 := objectMemory falseObject.
	self MoveCq: s57 R: t3.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 0 R: t3.
	jump2 := self JumpZero: 0.
	self ssPushRegister: t3.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimPointX [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: -31
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimPointY [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: -32
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimSize [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: -19
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimSubtract [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -2
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimValue [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: -26
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimValueWithArg [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -27
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_CallPrimitiveBytecode [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_DuplicateTopBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtABytecode [
	"AutoGenerated by Druid"

	| s5 s4 s2 currentBlock live s3 |
	live := 0.
	s2 := extA.
	s3 := s2 << 8.
	s4 := byte1.
	s5 := s3 + s4.
	extA := s5.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtBBytecode [
	"AutoGenerated by Druid"

	| s6 s3 s16 s10 s5 s2 currentBlock s7 s4 s17 live s11 s9 |
	live := 0.
	s2 := byte1.
	s3 := numExtB.
	s3 = 0 ifTrue: [
		s2 > 127 ifTrue: [
			s6 := s2 - 256.
			s7 := s6.
			extB := s7.
			s16 := numExtB.
			s17 := s16 + 1.
			numExtB := s17.
			^ 0 ].
		s9 := extB.
		s10 := s9 << 8.
		s11 := s10 + s2.
		s7 := s11.
		extB := s7.
		s16 := numExtB.
		s17 := s16 + 1.
		numExtB := s17.
		^ 0 ].
	s9 := extB.
	s10 := s9 << 8.
	s11 := s10 + s2.
	s7 := s11.
	extB := s7.
	s16 := numExtB.
	s17 := s16 + 1.
	numExtB := s17.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtJumpIfFalse [
	"AutoGenerated by Druid"

	| s6 s3 jump1 s16 s5 s2 s18 s15 currentBlock s12 t0 jump2 s4 s17 live s20 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self annotateBytecode: self Label.
	s3 := byte1.
	s4 := extB.
	s5 := s4 << 8.
	s6 := s3 + s5.
	extA := 0.
	extB := 0.
	numExtB := 0.
	(self ssValue: 0) copyToReg: t0.
	
	self ssUnspillTopStackSlots: 1.
	self ssPop: 1 popSpilled: false.
	
	s12 := objectMemory falseObject.
	self ssFlushStack.
	self CmpCq: s12 R: t0.
	jump1 := self JumpNonZero: 0.
	s15 := bytecodePC.
	s16 := s15 + s6.
	s17 := s16 + 2.
	self Jump: (self ensureFixupAt: s17).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s20 := objectMemory trueObject.
	self CmpCq: s20 R: t0.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtJumpIfTrue [
	"AutoGenerated by Druid"

	| s6 s3 jump1 s16 s5 s2 s18 s15 currentBlock s12 t0 jump2 s4 s17 live s20 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self annotateBytecode: self Label.
	s3 := byte1.
	s4 := extB.
	s5 := s4 << 8.
	s6 := s3 + s5.
	extA := 0.
	extB := 0.
	numExtB := 0.
	(self ssValue: 0) copyToReg: t0.
	
	self ssUnspillTopStackSlots: 1.
	self ssPop: 1 popSpilled: false.
	
	s12 := objectMemory trueObject.
	self ssFlushStack.
	self CmpCq: s12 R: t0.
	jump1 := self JumpNonZero: 0.
	s15 := bytecodePC.
	s16 := s15 + s6.
	s17 := s16 + 2.
	self Jump: (self ensureFixupAt: s17).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s20 := objectMemory falseObject.
	self CmpCq: s20 R: t0.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtNopBytecode [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	extB := 0.
	extA := 0.
	numExtB := 0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtPushCharacterBytecode [
	"AutoGenerated by Druid"

	| s5 s6 s4 s2 currentBlock s7 live s3 |
	live := 0.
	s2 := byte1.
	s3 := extB.
	s4 := s3 << 8.
	s5 := s2 + s4.
	s6 := s5 << 3.
	s7 := s6 + 2.
	self ssPushConstant: s7.
	extB := 0.
	numExtB := 0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtPushFullClosureBytecode [
	"AutoGenerated by Druid"

	| b4 s4 s38 s9 s2 s20 currentBlock t1 s19 s12 s7 s25 live s5 s15 s3 s28 s37 s21 t2 s8 t0 s18 s11 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	s2 := byte1.
	s3 := extA.
	s4 := s3 << 8.
	s5 := s2 + s4.
	extA := 0.
	s7 := byte2.
	s8 := s7 bitAnd: 63.
	s9 := s7 anyMask: 64.
	live := live bitOr: (self registerMaskFor: ReceiverResultReg).
	live := live bitOr: (self registerMaskFor: SendNumArgsReg).
	live := live bitOr: (self registerMaskFor: ClassReg).
	self voidReceiverResultRegContainsSelf.
	self
		ssAllocateCallReg: ReceiverResultReg
		and: SendNumArgsReg
		and: ClassReg.
	self
		genCreateFullClosureInIndex: s5
		numCopied: s8
		ignoreContext: s9
		contextNumArgs: methodOrBlockNumArgs
		large: (coInterpreter methodNeedsLargeContext: methodObj)
		inBlock: inBlock
		intoRegister: ReceiverResultReg.
	self MoveR: ReceiverResultReg R: t0.
	live := live bitClear: (self registerMaskFor: SendNumArgsReg).
	live := live bitClear: (self registerMaskFor: ClassReg).
	s11 := 1.
	s12 := s11.
	b4 := self Label.
	[ s12 <= s8 ] whileTrue: [
		(self ssValue: 0) copyToReg: t1.
		
		self ssUnspillTopStackSlots: 1.
		self ssPop: 1 popSpilled: false.
		
		s18 := FullClosureFirstCopiedValueIndex.
		s19 := s18 + s8.
		s20 := s19 - s12.
		s21 := s20 << 3.
		self MoveR: t0 R: t2.
		self AddCq: s21 R: t2.
		self MoveR: t1 M64: 8 r: t2.
		s25 := s12 + 1.
		s12 := s25 ].
	(s7 anyMask: 128) ifTrue: [
		(self ssValue: 0) copyToReg: t2.
		
		self ssUnspillTopStackSlots: 1.
		self ssPop: 1 popSpilled: false.
		
		s37 := FullClosureReceiverIndex.
		s38 := s37 << 3.
		self MoveR: t0 R: t1.
		self AddCq: s38 R: t1.
		self MoveR: t2 M64: 8 r: t1.
		self ssPushRegister: t0.
		^ 0 ].
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t2.
	s37 := FullClosureReceiverIndex.
	s38 := s37 << 3.
	self MoveR: t0 R: t1.
	self AddCq: s38 R: t1.
	self MoveR: t2 M64: 8 r: t1.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtPushIntegerBytecode [
	"AutoGenerated by Druid"

	| s5 s8 s4 s2 currentBlock s9 s10 live s3 |
	live := 0.
	s2 := byte1.
	s3 := extB.
	s4 := s3 << 8.
	s5 := s2 + s4.
	extB := 0.
	numExtB := 0.
	s8 := s2 + s4.
	s9 := s8 << 3.
	s10 := s9 + 1.
	self ssPushConstant: s10.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtPushLiteralBytecode [
	"AutoGenerated by Druid"

	| s3 s10 s8 s5 s2 currentBlock t0 s4 live s9 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	s2 := byte1.
	s3 := extA.
	s4 := s3 << 8.
	s5 := s2 + s4.
	extA := 0.
	self genMoveConstant: methodObj R: t0.
	s8 := LiteralStart.
	s9 := s5 + s8.
	s10 := s9 << 3.
	self AddCq: s10 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtPushLiteralVariableBytecode [
	"AutoGenerated by Druid"

	| s34 s3 jump1 jump4 s10 t1 s8 s5 s2 jump3 currentBlock t0 s35 s4 jump2 b233 live s9 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	s2 := byte1.
	s3 := extA.
	s4 := s3 << 8.
	s5 := s2 + s4.
	extA := 0.
	self genMoveConstant: methodObj R: t0.
	s8 := LiteralStart.
	s9 := s5 + s8.
	s10 := s9 << 3.
	self AddCq: s10 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s34 := ValueIndex.
	s35 := s34 << 3.
	self AddCq: s35 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtPushReceiverVariableBytecode [
	"AutoGenerated by Druid"

	| s6 s3 s13 s10 t1 s5 s2 s18 currentBlock t0 s4 live s9 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self annotateBytecode: self Label.
	s3 := byte1.
	s4 := extA.
	s5 := s4 << 8.
	s6 := s3 + s5.
	extA := 0.
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	s9 := StackPointerIndex.
	s6 <= s9 ifTrue: [
		| jump1 jump2 |
		self MoveM64: 0 r: t0 R: t1.
		self AndCq: 16r3FFFFF R: t1.
		s13 := ClassMethodContextCompactIndex.
		self CmpCq: s13 R: t1.
		jump1 := self JumpNonZero: 0.
		self ssFlushStack.
		self deoptimize.
		jump2 := self Jump: 0.
		deadCode := false.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		s18 := s6 << 3.
		self AddCq: s18 R: t0.
		self ssPushBase: t0 offset: 8.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		^ 0 ].
	s18 := s6 << 3.
	self AddCq: s18 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtSendBytecode [
	"AutoGenerated by Druid"

	| s6 s3 s10 s8 s5 s2 currentBlock s4 live s11 s9 |
	live := 0.
	s2 := byte1.
	s3 := s2 >> 3.
	s4 := extA.
	s5 := s4 << 5.
	s6 := s3 + s5.
	extA := 0.
	s8 := s2 bitAnd: 7.
	s9 := extB.
	s10 := s9 << 3.
	s11 := s8 + s10.
	extB := 0.
	numExtB := 0.
	self marshallSendArguments: s11.
	self
		genMarshalledSendNoPush: s6
		numArgs: s11
		sendTable: ordinarySendTrampolines.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtSendSuperBytecode [
	"AutoGenerated by Druid"

	| s6 s3 s16 s10 s8 s5 s2 s18 currentBlock s15 t0 s4 s17 live s11 s9 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	s2 := byte1.
	s3 := s2 >> 3.
	s4 := extA.
	s5 := s4 << 5.
	s6 := s3 + s5.
	extA := 0.
	s8 := BytecodeSetHasDirectedSuperSend.
	s8 ifTrue: [
		s10 := extB.
		s10 >= 64 ifTrue: [
			self ssFlushStack.
			self deoptimize.
			^ 0 ].
		s15 := s2 bitAnd: 7.
		s16 := extB.
		s17 := s16 << 3.
		s18 := s15 + s17.
		extB := 0.
		numExtB := 0.
		self marshallSendArguments: s18.
		self
			genMarshalledSendNoPush: s6
			numArgs: s18
			sendTable: superSendTrampolines.
		self ssPushRegister: ReceiverResultReg.
		^ 0 ].
	s15 := s2 bitAnd: 7.
	s16 := extB.
	s17 := s16 << 3.
	s18 := s15 + s17.
	extB := 0.
	numExtB := 0.
	self marshallSendArguments: s18.
	self
		genMarshalledSendNoPush: s6
		numArgs: s18
		sendTable: superSendTrampolines.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtStoreAndPopLiteralVariableBytecode [
	"AutoGenerated by Druid"

	| s6 jump5 jump7 s4 jump3 jump8 s2 t1 currentBlock jump1 s51 s12 jump6 s89 jumpNext s56 live s5 jump4 jumpTrue jump9 s3 s37 s85 t2 s59 s13 s61 b613 t0 s83 s48 jump2 s11 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	s3 := byte1.
	s4 := extA.
	s5 := s4 << 8.
	s6 := s3 + s5.
	(self ssValue: 0) copyToReg: t0.
	self ssUnspillTopStackSlots: 1.
	self ssPop: 1 popSpilled: false.
	extA := 0.
	self genMoveConstant: methodObj R: t1.
	s11 := LiteralStart.
	s12 := s6 + s11.
	s13 := s12 << 3.
	self AddCq: s13 R: t1.
	self MoveM64: 8 r: t1 R: t1.
	self MoveM64: 0 r: t1 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t2.
	b613 := self Label.
	self MoveR: t2 R: t1.
	self AndCq: 7 R: t1.
	self CmpCq: 0 R: t1.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t1.
	self MoveR: t1 R: t2.
	jump4 := self Jump: b613.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t2 R: t1.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s37 := ValueIndex.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump3 := self JumpZero: 0.
	self deoptimize.
	jump1 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	s48 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s48 R: t2.
	s51 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s51 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump5 := self JumpNonZero: 0.
	s56 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s56 R: t2.
	s59 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s59 R: t2.
	jump6 := self JumpNonZero: 0.
	s61 := objectMemory getMemoryMap getNewSpaceStart.
	self MoveR: t0 R: t2.
	self CmpCq: s61 R: t2.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump8 := self JumpNonZero: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump9 := self JumpNonZero: 0.
	self TstCq: 7 R: t0.
	jump8 := self JumpNonZero: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump7 := self JumpBelow: 0.
	self CmpCq: 16r20000000000 R: t0.
	jump5 := self JumpGreaterOrEqual: 0.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t0.
	jump2 := self JumpBelow: 0.
	s83 := objectMemory trueObject.
	self CmpCq: s83 R: t0.
	jump3 := self JumpBelowOrEqual: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	s85 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s85 R: t0.
	jump2 := self JumpBelow: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	s89 := s37 << 3.
	self AddCq: s89 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtStoreAndPopReceiverVariableBytecode [
	"AutoGenerated by Druid"

	| s6 jump5 s33 s46 s4 jump3 s44 s69 s14 s2 s36 currentBlock s9 t1 jump1 jump6 s65 s5 live jump4 s63 s3 t2 jump2 jump7 t0 s41 s11 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	s3 := byte1.
	s4 := extA.
	s5 := s4 << 8.
	s6 := s3 + s5.
	(self ssValue: 0) copyToReg: t0.
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t1.
	s9 := ReceiverIndex.
	self ssFlushStack.
	s6 <= s9 ifTrue: [
		| jump7 jump5 jump3 jump1 jump8 jump6 jump4 jump2 |
		self MoveM64: 0 r: t1 R: t2.
		self AndCq: 16r3FFFFF R: t2.
		s14 := ClassMethodContextCompactIndex.
		self CmpCq: s14 R: t2.
		jump1 := self JumpNonZero: 0.
		self deoptimize.
		jump2 := self Jump: 0.
		deadCode := false.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self ssPop: 1 popSpilled: true.
		self MoveM64: 0 r: t1 R: t2.
		self LogicalShiftRightCq: 23 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump1 := self JumpZero: 0.
		self deoptimize.
		jump3 := self Jump: 0.
		deadCode := false.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self MoveR: t1 R: t2.
		self AndCq: 7 R: t2.
		self CmpCq: 0 R: t2.
		jump1 := self JumpNonZero: 0.
		s33 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveR: t1 R: t2.
		self AndCq: s33 R: t2.
		s36 := objectMemory getMemoryMap getOldSpaceMask.
		self CmpCq: s36 R: t2.
		jump4 := self JumpNonZero: 0.
		self MoveR: t0 R: t2.
		self AndCq: 7 R: t2.
		self CmpCq: 0 R: t2.
		jump5 := self JumpNonZero: 0.
		s41 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveR: t0 R: t2.
		self AndCq: s41 R: t2.
		s44 := objectMemory getMemoryMap getNewSpaceMask.
		self CmpCq: s44 R: t2.
		jump6 := self JumpNonZero: 0.
		s46 := objectMemory getMemoryMap getNewSpaceStart.
		self CmpCq: s46 R: t0.
		jump7 := self JumpBelow: 0.
		self MoveM64: 0 r: t1 R: t2.
		self LogicalShiftRightCq: 29 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump8 := self JumpNonZero: 0.
		self MoveR: t1 R: TempReg.
		backEnd saveAndRestoreLinkRegAround: [
			self CallRT: ceStoreCheckTrampoline ].
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		jump4 jmpTarget: currentBlock.
		jump5 jmpTarget: currentBlock.
		jump6 jmpTarget: currentBlock.
		jump7 jmpTarget: currentBlock.
		jump8 jmpTarget: currentBlock.
		self MoveM64: 0 r: t1 R: t2.
		self LogicalShiftRightCq: 29 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump8 := self JumpNonZero: 0.
		self TstCq: 7 R: t0.
		jump7 := self JumpNonZero: 0.
		self CmpCq: 16r20000000000 R: t1.
		jump6 := self JumpLess: 0.
		self CmpCq: 16r20000000000 R: t0.
		jump5 := self JumpGreaterOrEqual: 0.
		self genMoveConstant: objectMemory nilObject R: t2.
		self CmpR: t2 R: t0.
		jump4 := self JumpBelow: 0.
		s63 := objectMemory trueObject.
		self CmpCq: s63 R: t0.
		jump1 := self JumpBelowOrEqual: 0.
		currentBlock := self Label.
		jump4 jmpTarget: currentBlock.
		s65 := objectMemory getMemoryMap getNewSpaceStart.
		self CmpCq: s65 R: t0.
		jump4 := self JumpBelow: 0.
		self MoveR: t1 R: TempReg.
		backEnd saveAndRestoreLinkRegAround: [
			self CallRT: ceStoreCheckTrampoline ].
		currentBlock := self Label.
		jump8 jmpTarget: currentBlock.
		jump7 jmpTarget: currentBlock.
		jump6 jmpTarget: currentBlock.
		jump5 jmpTarget: currentBlock.
		jump1 jmpTarget: currentBlock.
		jump4 jmpTarget: currentBlock.
		s69 := s6 << 3.
		self AddCq: s69 R: t1.
		self MoveR: t0 M64: 8 r: t1.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		extA := 0.
		^ 0 ].
	self ssPop: 1 popSpilled: true.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	s33 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s33 R: t2.
	s36 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s36 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s41 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s41 R: t2.
	s44 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s44 R: t2.
	jump5 := self JumpNonZero: 0.
	s46 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s46 R: t0.
	jump6 := self JumpBelow: 0.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self TstCq: 7 R: t0.
	jump6 := self JumpNonZero: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump5 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t0.
	jump1 := self JumpGreaterOrEqual: 0.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t0.
	jump4 := self JumpBelow: 0.
	s63 := objectMemory trueObject.
	self CmpCq: s63 R: t0.
	jump3 := self JumpBelowOrEqual: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	s65 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s65 R: t0.
	jump4 := self JumpBelow: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	s69 := s6 << 3.
	self AddCq: s69 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	extA := 0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtStoreLiteralVariableBytecode [
	"AutoGenerated by Druid"

	| s6 s11 s88 jump5 s55 s4 jump3 jump8 s2 s36 currentBlock s84 s58 s12 s60 t1 jump1 s82 s47 jump6 s10 s5 live jump4 jumpTrue jumpNext jump9 s3 t2 jump2 b613 jump7 t0 s50 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	s3 := byte1.
	s4 := extA.
	s5 := s4 << 8.
	s6 := s3 + s5.
	extA := 0.
	(self ssValue: 0) copyToReg: t0.
	self genMoveConstant: methodObj R: t1.
	s10 := LiteralStart.
	s11 := s6 + s10.
	s12 := s11 << 3.
	self AddCq: s12 R: t1.
	self MoveM64: 8 r: t1 R: t1.
	self MoveM64: 0 r: t1 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t2.
	b613 := self Label.
	self MoveR: t2 R: t1.
	self AndCq: 7 R: t1.
	self CmpCq: 0 R: t1.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t1.
	self MoveR: t1 R: t2.
	jump4 := self Jump: b613.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t2 R: t1.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s36 := ValueIndex.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump3 := self JumpZero: 0.
	self deoptimize.
	jump1 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	s47 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s47 R: t2.
	s50 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s50 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump5 := self JumpNonZero: 0.
	s55 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s55 R: t2.
	s58 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s58 R: t2.
	jump6 := self JumpNonZero: 0.
	s60 := objectMemory getMemoryMap getNewSpaceStart.
	self MoveR: t0 R: t2.
	self CmpCq: s60 R: t2.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump8 := self JumpNonZero: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump9 := self JumpNonZero: 0.
	self TstCq: 7 R: t0.
	jump8 := self JumpNonZero: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump7 := self JumpBelow: 0.
	self CmpCq: 16r20000000000 R: t0.
	jump5 := self JumpGreaterOrEqual: 0.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t0.
	jump2 := self JumpBelow: 0.
	s82 := objectMemory trueObject.
	self CmpCq: s82 R: t0.
	jump3 := self JumpBelowOrEqual: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	s84 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s84 R: t0.
	jump2 := self JumpBelow: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	s88 := s36 << 3.
	self AddCq: s88 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtStoreReceiverVariableBytecode [
	"AutoGenerated by Druid"

	| s6 jump5 s4 jump3 s31 s44 s14 s9 s2 t1 currentBlock jump1 s42 s67 jump6 s34 live s5 s39 jump4 s63 s3 t2 jump2 s61 jump7 t0 s11 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	s3 := byte1.
	s4 := extA.
	s5 := s4 << 8.
	s6 := s3 + s5.
	(self ssValue: 0) copyToReg: t0.
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t1.
	s9 := ReceiverIndex.
	self ssFlushStack.
	s6 <= s9 ifTrue: [
		| jump7 jump5 jump3 jump1 jump8 jump6 jump4 jump2 |
		self MoveM64: 0 r: t1 R: t2.
		self AndCq: 16r3FFFFF R: t2.
		s14 := ClassMethodContextCompactIndex.
		self CmpCq: s14 R: t2.
		jump1 := self JumpNonZero: 0.
		self deoptimize.
		jump2 := self Jump: 0.
		deadCode := false.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self MoveM64: 0 r: t1 R: t2.
		self LogicalShiftRightCq: 23 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump1 := self JumpZero: 0.
		self deoptimize.
		jump3 := self Jump: 0.
		deadCode := false.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self MoveR: t1 R: t2.
		self AndCq: 7 R: t2.
		self CmpCq: 0 R: t2.
		jump1 := self JumpNonZero: 0.
		s31 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveR: t1 R: t2.
		self AndCq: s31 R: t2.
		s34 := objectMemory getMemoryMap getOldSpaceMask.
		self CmpCq: s34 R: t2.
		jump4 := self JumpNonZero: 0.
		self MoveR: t0 R: t2.
		self AndCq: 7 R: t2.
		self CmpCq: 0 R: t2.
		jump5 := self JumpNonZero: 0.
		s39 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveR: t0 R: t2.
		self AndCq: s39 R: t2.
		s42 := objectMemory getMemoryMap getNewSpaceMask.
		self CmpCq: s42 R: t2.
		jump6 := self JumpNonZero: 0.
		s44 := objectMemory getMemoryMap getNewSpaceStart.
		self CmpCq: s44 R: t0.
		jump7 := self JumpBelow: 0.
		self MoveM64: 0 r: t1 R: t2.
		self LogicalShiftRightCq: 29 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump8 := self JumpNonZero: 0.
		self MoveR: t1 R: TempReg.
		backEnd saveAndRestoreLinkRegAround: [
			self CallRT: ceStoreCheckTrampoline ].
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		jump4 jmpTarget: currentBlock.
		jump5 jmpTarget: currentBlock.
		jump6 jmpTarget: currentBlock.
		jump7 jmpTarget: currentBlock.
		jump8 jmpTarget: currentBlock.
		self MoveM64: 0 r: t1 R: t2.
		self LogicalShiftRightCq: 29 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump8 := self JumpNonZero: 0.
		self TstCq: 7 R: t0.
		jump7 := self JumpNonZero: 0.
		self CmpCq: 16r20000000000 R: t1.
		jump6 := self JumpLess: 0.
		self CmpCq: 16r20000000000 R: t0.
		jump5 := self JumpGreaterOrEqual: 0.
		self genMoveConstant: objectMemory nilObject R: t2.
		self CmpR: t2 R: t0.
		jump4 := self JumpBelow: 0.
		s61 := objectMemory trueObject.
		self CmpCq: s61 R: t0.
		jump1 := self JumpBelowOrEqual: 0.
		currentBlock := self Label.
		jump4 jmpTarget: currentBlock.
		s63 := objectMemory getMemoryMap getNewSpaceStart.
		self CmpCq: s63 R: t0.
		jump4 := self JumpBelow: 0.
		self MoveR: t1 R: TempReg.
		backEnd saveAndRestoreLinkRegAround: [
			self CallRT: ceStoreCheckTrampoline ].
		currentBlock := self Label.
		jump8 jmpTarget: currentBlock.
		jump7 jmpTarget: currentBlock.
		jump6 jmpTarget: currentBlock.
		jump5 jmpTarget: currentBlock.
		jump1 jmpTarget: currentBlock.
		jump4 jmpTarget: currentBlock.
		s67 := s6 << 3.
		self AddCq: s67 R: t1.
		self MoveR: t0 M64: 8 r: t1.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		extA := 0.
		^ 0 ].
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	s31 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s31 R: t2.
	s34 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s34 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s39 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s39 R: t2.
	s42 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s42 R: t2.
	jump5 := self JumpNonZero: 0.
	s44 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s44 R: t0.
	jump6 := self JumpBelow: 0.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self TstCq: 7 R: t0.
	jump6 := self JumpNonZero: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump5 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t0.
	jump1 := self JumpGreaterOrEqual: 0.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t0.
	jump4 := self JumpBelow: 0.
	s61 := objectMemory trueObject.
	self CmpCq: s61 R: t0.
	jump3 := self JumpBelowOrEqual: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	s63 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s63 R: t0.
	jump4 := self JumpBelow: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	s67 := s6 << 3.
	self AddCq: s67 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	extA := 0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtUnconditionalJump [
	"AutoGenerated by Druid"

	| s6 s4 s29 s9 s2 s27 currentBlock s20 t1 s12 s7 jump1 s10 s5 live s3 s28 s8 s26 t0 s18 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self annotateBytecode: self Label.
	s3 := byte1.
	s4 := extB.
	s5 := s4 << 8.
	s6 := s3 + s5.
	s6 < 0 ifTrue: [
		| jump1 |
		s8 := numExtB.
		s9 := s8 << 1.
		s10 := s9.
		extB := 0.
		numExtB := 0.
		s18 := s6 + s10.
		self ssFlushStack.
		s18 >= 0 ifTrue: [
			s26 := bytecodePC.
			s27 := s26 + s6.
			s28 := s27 + 2.
			self Jump: (self ensureFixupAt: s28).
			deadCode := true.
			^ 0 ].
		self MoveR: SPReg R: t0.
		self MoveAw: coInterpreter stackLimitAddress R: t1.
		self CmpR: t1 R: t0.
		jump1 := self JumpAboveOrEqual: 0.
		self CallRT: ceCheckForInterruptTrampoline.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		s26 := bytecodePC.
		s27 := s26 + s6.
		s28 := s27 + 2.
		self Jump: (self ensureFixupAt: s28).
		deadCode := true.
		^ 0 ].
	s12 := 0.
	s10 := s12.
	extB := 0.
	numExtB := 0.
	s18 := s6 + s10.
	self ssFlushStack.
	s18 >= 0 ifTrue: [
		s26 := bytecodePC.
		s27 := s26 + s6.
		s28 := s27 + 2.
		self Jump: (self ensureFixupAt: s28).
		deadCode := true.
		^ 0 ].
	self MoveR: SPReg R: t0.
	self MoveAw: coInterpreter stackLimitAddress R: t1.
	self CmpR: t1 R: t0.
	jump1 := self JumpAboveOrEqual: 0.
	self CallRT: ceCheckForInterruptTrampoline.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s26 := bytecodePC.
	s27 := s26 + s6.
	s28 := s27 + 2.
	self Jump: (self ensureFixupAt: s28).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_LongPushTemporaryVariableBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: byte1) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_LongStoreAndPopTemporaryVariableBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssFlushUpThroughTemporaryVariable: byte1.
	self MoveR: t0 Mw: (self frameOffsetOfTemporary: byte1) r: FPReg.
	self ssUnspillTopStackSlots: 1.
	self ssPop: 1 popSpilled: false.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_LongStoreTemporaryVariableBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssFlushUpThroughTemporaryVariable: byte1.
	self MoveR: t0 Mw: (self frameOffsetOfTemporary: byte1) r: FPReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PopStackBytecode [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self ssUnspillTopStackSlots: 1.
	self ssPop: 1 popSpilled: false.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushConstantFalseBytecode [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := objectMemory falseObject.
	self ssPushConstant: s2.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushConstantNilBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: objectMemory nilObject R: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushConstantOneBytecode [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := ConstOne.
	self ssPushConstant: s2.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushConstantTrueBytecode [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := objectMemory trueObject.
	self ssPushConstant: s2.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushConstantZeroBytecode [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := ConstZero.
	self ssPushConstant: s2.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode0 [
	"AutoGenerated by Druid"

	| t0 s4 currentBlock live s3 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 << 3.
	self AddCq: s4 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode1 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 1.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode10 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 10.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode11 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 11.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode12 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 12.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode13 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 13.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode14 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 14.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode15 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 15.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode16 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 16.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode17 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 17.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode18 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 18.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode19 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 19.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode2 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 2.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode20 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 20.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode21 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 21.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode22 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 22.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode23 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 23.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode24 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 24.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode25 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 25.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode26 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 26.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode27 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 27.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode28 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 28.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode29 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 29.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode3 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 3.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode30 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 30.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode31 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 31.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode4 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 4.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode5 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 5.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode6 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 6.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode7 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 7.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode8 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 8.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode9 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 9.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode0 [
	"AutoGenerated by Druid"

	| jump1 s3 s28 t1 jump3 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 << 3.
	self AddCq: s4 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s28 := ValueIndex.
	s29 := s28 << 3.
	self AddCq: s29 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode1 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 1.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode10 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 10.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode11 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 11.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode12 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 12.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode13 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 13.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode14 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 14.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode15 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 15.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode2 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 2.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode3 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 3.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode4 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 4.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode5 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 5.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode6 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 6.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode7 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 7.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode8 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 8.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode9 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 9.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushNewArrayBytecode [
	"AutoGenerated by Druid"

	| s6 s50 s33 s46 s4 s29 s38 b109 s2 s27 currentBlock s20 s19 s42 s7 t1 s34 jump1 s47 s17 s10 live s56 s45 s3 s28 s30 s21 t2 s52 s8 s35 t0 s11 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	s2 := byte1.
	s3 := s2 bitAnd: 127.
	s4 := ClassArrayCompactIndex.
	self MoveAw: objectMemory freeStartAddress R: t0.
	s3 < 1 ifTrue: [
		| jump1 b109 |
		s7 := 16.
		s8 := s7.
		self MoveAw: objectMemory freeStartAddress R: t1.
		self AddCq: s8 R: t1.
		s17 := objectMemory getScavengeThreshold.
		self CmpCq: s17 R: t1.
		jump1 := self JumpAbove: 0.
		s19 := s3 << 56.
		s20 := s19 + s4.
		s21 := s20 + 33554432.
		self MoveCq: s21 R: t1.
		self MoveR: t1 M64: 0 r: t0.
		self MoveAw: objectMemory freeStartAddress R: t1.
		self AddCq: s8 R: t1.
		self MoveR: t1 Aw: objectMemory freeStartAddress.
		s2 > 127 ifTrue: [
			| b81 |
			s28 := 0.
			s29 := s3 - 1.
			s30 := s28.
			b81 := self Label.
			[ ((s30<=s29)) ] whileTrue: [
				s34 := s3 - s30.
				s35 := s34 - 1.
				(self ssValue: 0) copyToReg: t1.
				self ssPop: 1 popSpilled: true.
				s38 := s35 << 3.
				self MoveR: t0 R: t2.
				self AddCq: s38 R: t2.
				self MoveR: t1 M64: 8 r: t2.
				s42 := s30 + 1.
				s30 := s42 ].
			self ssPushRegister: t0.
			currentBlock := self Label.
			jump1 jmpTarget: currentBlock.
			^ 0 ].
		s45 := 0.
		s46 := s3 - 1.
		s47 := s45.
		b109 := self Label.
		[ ((s47<=s46)) ] whileTrue: [
			self genMoveConstant: objectMemory nilObject R: t2.
			s52 := s47 << 3.
			self MoveR: t0 R: t1.
			self AddCq: s52 R: t1.
			self MoveR: t2 M64: 8 r: t1.
			s56 := s47 + 1.
			s47 := s56 ].
		self ssPushRegister: t0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	s10 := s3 << 3.
	s11 := s10 + 8.
	s8 := s11.
	self MoveAw: objectMemory freeStartAddress R: t1.
	self AddCq: s8 R: t1.
	s17 := objectMemory getScavengeThreshold.
	self CmpCq: s17 R: t1.
	jump1 := self JumpAbove: 0.
	s19 := s3 << 56.
	s20 := s19 + s4.
	s21 := s20 + 33554432.
	self MoveCq: s21 R: t1.
	self MoveR: t1 M64: 0 r: t0.
	self MoveAw: objectMemory freeStartAddress R: t1.
	self AddCq: s8 R: t1.
	self MoveR: t1 Aw: objectMemory freeStartAddress.
	s2 > 127 ifTrue: [
		| b81 |
		s28 := 0.
		s29 := s3 - 1.
		s30 := s28.
		b81 := self Label.
		[ ((s30<=s29)) ] whileTrue: [
			s34 := s3 - s30.
			s35 := s34 - 1.
			(self ssValue: 0) copyToReg: t1.
			self ssPop: 1 popSpilled: true.
			s38 := s35 << 3.
			self MoveR: t0 R: t2.
			self AddCq: s38 R: t2.
			self MoveR: t1 M64: 8 r: t2.
			s42 := s30 + 1.
			s30 := s42 ].
		self ssPushRegister: t0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	s45 := 0.
	s46 := s3 - 1.
	s47 := s45.
	b109 := self Label.
	[ ((s47<=s46)) ] whileTrue: [
		self genMoveConstant: objectMemory nilObject R: t2.
		s52 := s47 << 3.
		self MoveR: t0 R: t1.
		self AddCq: s52 R: t1.
		self MoveR: t2 M64: 8 r: t1.
		s56 := s47 + 1.
		s47 := s56 ].
	self ssPushRegister: t0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode0 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode1 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 16.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode10 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 88.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode11 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 96.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode12 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 104.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode13 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 112.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode14 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 120.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode15 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 128.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode2 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 24.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode3 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 32.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode4 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 40.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode5 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 48.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode6 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 56.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode7 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 64.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode8 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 72.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode9 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 80.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushRemoteTempLongBytecode [
	"AutoGenerated by Druid"

	| t0 s32 s4 s2 currentBlock t1 live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	s2 := byte1.
	(self simStackTempAt: byte2) copyToReg: t0.
	s4 := TempVectReadBarrier.
	s4 ifTrue: [
		| jump3 jump1 b199 jump4 jump2 |
		self MoveM64: 0 r: t0 R: t1.
		self AndCq: 16r3FFFF7 R: t1.
		self CmpCq: 0 R: t1.
		jump1 := self JumpNonZero: 0.
		self MoveM64: 8 r: t0 R: t1.
		b199 := self Label.
		self MoveR: t1 R: t0.
		self AndCq: 7 R: t0.
		self CmpCq: 0 R: t0.
		jump2 := self JumpNonZero: 0.
		self MoveM64: 0 r: t1 R: t0.
		self AndCq: 16r3FFFF7 R: t0.
		self CmpCq: 0 R: t0.
		jump3 := self JumpNonZero: 0.
		self MoveM64: 8 r: t1 R: t0.
		self MoveR: t0 R: t1.
		jump4 := self Jump: b199.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		self MoveR: t1 R: t0.
		jump3 := self Jump: 0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		s32 := s2 << 3.
		self AddCq: s32 R: t0.
		self ssPushBase: t0 offset: 8.
		^ 0 ].
	s32 := s2 << 3.
	self AddCq: s32 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushTemporaryVariableBytecode0 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 0) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushTemporaryVariableBytecode1 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 1) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushTemporaryVariableBytecode10 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 10) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushTemporaryVariableBytecode11 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 11) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushTemporaryVariableBytecode2 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 2) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushTemporaryVariableBytecode3 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 3) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushTemporaryVariableBytecode4 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 4) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushTemporaryVariableBytecode5 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 5) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushTemporaryVariableBytecode6 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 6) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushTemporaryVariableBytecode7 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 7) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushTemporaryVariableBytecode8 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 8) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushTemporaryVariableBytecode9 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 9) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ReturnFalse [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := objectMemory falseObject.
	self MoveCq: s2 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ReturnNil [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: objectMemory nilObject R: t0.
	self MoveR: t0 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ReturnNilFromBlock [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: objectMemory nilObject R: t0.
	self MoveR: t0 R: ReceiverResultReg.
	self genBlockReturn.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ReturnReceiver [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	self MoveR: t0 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ReturnTopFromBlock [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	self MoveR: t0 R: ReceiverResultReg.
	self genBlockReturn.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ReturnTopFromMethod [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	self MoveR: t0 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ReturnTrue [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := objectMemory trueObject.
	self MoveCq: s2 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode0 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 0
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode1 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 1
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode10 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 10
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode11 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 11
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode12 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 12
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode13 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 13
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode14 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 14
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode15 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 15
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode2 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 2
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode3 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 3
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode4 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 4
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode5 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 5
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode6 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 6
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode7 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 7
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode8 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 8
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode9 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 9
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode0 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 0
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode1 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 1
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode10 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 10
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode11 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 11
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode12 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 12
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode13 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 13
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode14 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 14
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode15 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 15
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode2 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 2
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode3 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 3
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode4 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 4
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode5 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 5
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode6 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 6
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode7 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 7
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode8 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 8
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode9 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 9
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode0 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 0
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode1 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 1
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode10 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 10
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode11 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 11
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode12 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 12
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode13 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 13
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode14 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 14
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode15 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 15
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode2 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 2
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode3 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 3
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode4 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 4
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode5 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 5
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode6 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 6
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode7 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 7
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode8 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 8
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode9 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 9
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushRegister: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpFalse0 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self annotateBytecode: self Label.
	(self ssValue: 0) copyToReg: t0.
	
	self ssUnspillTopStackSlots: 1.
	self ssPop: 1 popSpilled: false.

	s5 := objectMemory falseObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 2.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory trueObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpFalse1 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self annotateBytecode: self Label.
	(self ssValue: 0) copyToReg: t0.
	
	self ssUnspillTopStackSlots: 1.
	self ssPop: 1 popSpilled: false.
	
	s5 := objectMemory falseObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 3.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory trueObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpFalse2 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self annotateBytecode: self Label.
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory falseObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 4.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory trueObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpFalse3 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self annotateBytecode: self Label.
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory falseObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 5.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory trueObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpFalse4 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self annotateBytecode: self Label.
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory falseObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 6.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory trueObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpFalse5 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self annotateBytecode: self Label.
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory falseObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 7.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory trueObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpFalse6 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self annotateBytecode: self Label.
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory falseObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 8.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory trueObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpFalse7 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self annotateBytecode: self Label.
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory falseObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 9.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory trueObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpTrue0 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self annotateBytecode: self Label.
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory trueObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 2.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory falseObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpTrue1 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self annotateBytecode: self Label.
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory trueObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 3.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory falseObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpTrue2 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self annotateBytecode: self Label.
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory trueObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 4.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory falseObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpTrue3 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self annotateBytecode: self Label.
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory trueObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 5.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory falseObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpTrue4 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self annotateBytecode: self Label.
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory trueObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 6.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory falseObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpTrue5 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self annotateBytecode: self Label.
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory trueObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 7.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory falseObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpTrue6 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self annotateBytecode: self Label.
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory trueObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 8.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory falseObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpTrue7 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self annotateBytecode: self Label.
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory trueObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 9.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory falseObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpZero: 0.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortUnconditionalJump0 [
	"AutoGenerated by Druid"

	| s5 s2 currentBlock live s3 |
	live := 0.
	s2 := bytecodePC.
	s3 := s2 + 2.
	self ssFlushStack.
	self Jump: (self ensureFixupAt: s3).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortUnconditionalJump1 [
	"AutoGenerated by Druid"

	| s5 s2 currentBlock live s3 |
	live := 0.
	s2 := bytecodePC.
	s3 := s2 + 3.
	self ssFlushStack.
	self Jump: (self ensureFixupAt: s3).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortUnconditionalJump2 [
	"AutoGenerated by Druid"

	| s5 s2 currentBlock live s3 |
	live := 0.
	s2 := bytecodePC.
	s3 := s2 + 4.
	self ssFlushStack.
	self Jump: (self ensureFixupAt: s3).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortUnconditionalJump3 [
	"AutoGenerated by Druid"

	| s5 s2 currentBlock live s3 |
	live := 0.
	s2 := bytecodePC.
	s3 := s2 + 5.
	self ssFlushStack.
	self Jump: (self ensureFixupAt: s3).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortUnconditionalJump4 [
	"AutoGenerated by Druid"

	| s5 s2 currentBlock live s3 |
	live := 0.
	s2 := bytecodePC.
	s3 := s2 + 6.
	self ssFlushStack.
	self Jump: (self ensureFixupAt: s3).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortUnconditionalJump5 [
	"AutoGenerated by Druid"

	| s5 s2 currentBlock live s3 |
	live := 0.
	s2 := bytecodePC.
	s3 := s2 + 7.
	self ssFlushStack.
	self Jump: (self ensureFixupAt: s3).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortUnconditionalJump6 [
	"AutoGenerated by Druid"

	| s5 s2 currentBlock live s3 |
	live := 0.
	s2 := bytecodePC.
	s3 := s2 + 8.
	self ssFlushStack.
	self Jump: (self ensureFixupAt: s3).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortUnconditionalJump7 [
	"AutoGenerated by Druid"

	| s5 s2 currentBlock live s3 |
	live := 0.
	s2 := bytecodePC.
	s3 := s2 + 9.
	self ssFlushStack.
	self Jump: (self ensureFixupAt: s3).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopReceiverVariableBytecode0 [
	"AutoGenerated by Druid"

	| jump5 s24 s46 s16 jump3 s29 jump1 t1 s2 currentBlock s19 s27 jump6 live jump4 jump2 t2 jump7 t0 s48 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1 popSpilled: true.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s16 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s16 R: t2.
	s19 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s19 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	s24 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s24 R: t2.
	s27 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s27 R: t2.
	jump5 := self JumpNonZero: 0.
	s29 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s29 R: t1.
	jump6 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self TstCq: 7 R: t1.
	jump6 := self JumpNonZero: 0.
	self CmpCq: 16r20000000000 R: t0.
	jump5 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump4 := self JumpGreaterOrEqual: 0.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t1.
	jump3 := self JumpBelow: 0.
	s46 := objectMemory trueObject.
	self CmpCq: s46 R: t1.
	jump1 := self JumpBelowOrEqual: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s48 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s48 R: t1.
	jump3 := self JumpBelow: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 M64: 8 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopReceiverVariableBytecode1 [
	"AutoGenerated by Druid"

	| jump5 s24 s46 s16 jump3 s29 jump1 t1 s2 currentBlock s19 s27 jump6 live jump4 jump2 t2 jump7 t0 s48 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1 popSpilled: true.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s16 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s16 R: t2.
	s19 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s19 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	s24 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s24 R: t2.
	s27 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s27 R: t2.
	jump5 := self JumpNonZero: 0.
	s29 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s29 R: t1.
	jump6 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self TstCq: 7 R: t1.
	jump6 := self JumpNonZero: 0.
	self CmpCq: 16r20000000000 R: t0.
	jump5 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump4 := self JumpGreaterOrEqual: 0.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t1.
	jump3 := self JumpBelow: 0.
	s46 := objectMemory trueObject.
	self CmpCq: s46 R: t1.
	jump1 := self JumpBelowOrEqual: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s48 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s48 R: t1.
	jump3 := self JumpBelow: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 M64: 16 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopReceiverVariableBytecode2 [
	"AutoGenerated by Druid"

	| jump5 s24 s46 s16 jump3 s29 jump1 t1 s2 currentBlock s19 s27 jump6 live jump4 jump2 t2 jump7 t0 s48 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1 popSpilled: true.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s16 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s16 R: t2.
	s19 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s19 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	s24 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s24 R: t2.
	s27 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s27 R: t2.
	jump5 := self JumpNonZero: 0.
	s29 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s29 R: t1.
	jump6 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self TstCq: 7 R: t1.
	jump6 := self JumpNonZero: 0.
	self CmpCq: 16r20000000000 R: t0.
	jump5 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump4 := self JumpGreaterOrEqual: 0.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t1.
	jump3 := self JumpBelow: 0.
	s46 := objectMemory trueObject.
	self CmpCq: s46 R: t1.
	jump1 := self JumpBelowOrEqual: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s48 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s48 R: t1.
	jump3 := self JumpBelow: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 M64: 24 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopReceiverVariableBytecode3 [
	"AutoGenerated by Druid"

	| jump5 s24 s46 s16 jump3 s29 jump1 t1 s2 currentBlock s19 s27 jump6 live jump4 jump2 t2 jump7 t0 s48 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1 popSpilled: true.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s16 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s16 R: t2.
	s19 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s19 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	s24 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s24 R: t2.
	s27 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s27 R: t2.
	jump5 := self JumpNonZero: 0.
	s29 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s29 R: t1.
	jump6 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self TstCq: 7 R: t1.
	jump6 := self JumpNonZero: 0.
	self CmpCq: 16r20000000000 R: t0.
	jump5 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump4 := self JumpGreaterOrEqual: 0.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t1.
	jump3 := self JumpBelow: 0.
	s46 := objectMemory trueObject.
	self CmpCq: s46 R: t1.
	jump1 := self JumpBelowOrEqual: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s48 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s48 R: t1.
	jump3 := self JumpBelow: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 M64: 32 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopReceiverVariableBytecode4 [
	"AutoGenerated by Druid"

	| jump5 s24 s46 s16 jump3 s29 jump1 t1 s2 currentBlock s19 s27 jump6 live jump4 jump2 t2 jump7 t0 s48 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1 popSpilled: true.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s16 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s16 R: t2.
	s19 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s19 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	s24 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s24 R: t2.
	s27 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s27 R: t2.
	jump5 := self JumpNonZero: 0.
	s29 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s29 R: t1.
	jump6 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self TstCq: 7 R: t1.
	jump6 := self JumpNonZero: 0.
	self CmpCq: 16r20000000000 R: t0.
	jump5 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump4 := self JumpGreaterOrEqual: 0.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t1.
	jump3 := self JumpBelow: 0.
	s46 := objectMemory trueObject.
	self CmpCq: s46 R: t1.
	jump1 := self JumpBelowOrEqual: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s48 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s48 R: t1.
	jump3 := self JumpBelow: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 M64: 40 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopReceiverVariableBytecode5 [
	"AutoGenerated by Druid"

	| jump5 s24 s46 s16 jump3 s29 jump1 t1 s2 currentBlock s19 s27 jump6 live jump4 jump2 t2 jump7 t0 s48 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1 popSpilled: true.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s16 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s16 R: t2.
	s19 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s19 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	s24 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s24 R: t2.
	s27 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s27 R: t2.
	jump5 := self JumpNonZero: 0.
	s29 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s29 R: t1.
	jump6 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self TstCq: 7 R: t1.
	jump6 := self JumpNonZero: 0.
	self CmpCq: 16r20000000000 R: t0.
	jump5 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump4 := self JumpGreaterOrEqual: 0.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t1.
	jump3 := self JumpBelow: 0.
	s46 := objectMemory trueObject.
	self CmpCq: s46 R: t1.
	jump1 := self JumpBelowOrEqual: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s48 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s48 R: t1.
	jump3 := self JumpBelow: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 M64: 48 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopReceiverVariableBytecode6 [
	"AutoGenerated by Druid"

	| jump5 s24 s46 s16 jump3 s29 jump1 t1 s2 currentBlock s19 s27 jump6 live jump4 jump2 t2 jump7 t0 s48 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1 popSpilled: true.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s16 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s16 R: t2.
	s19 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s19 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	s24 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s24 R: t2.
	s27 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s27 R: t2.
	jump5 := self JumpNonZero: 0.
	s29 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s29 R: t1.
	jump6 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self TstCq: 7 R: t1.
	jump6 := self JumpNonZero: 0.
	self CmpCq: 16r20000000000 R: t0.
	jump5 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump4 := self JumpGreaterOrEqual: 0.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t1.
	jump3 := self JumpBelow: 0.
	s46 := objectMemory trueObject.
	self CmpCq: s46 R: t1.
	jump1 := self JumpBelowOrEqual: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s48 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s48 R: t1.
	jump3 := self JumpBelow: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 M64: 56 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopReceiverVariableBytecode7 [
	"AutoGenerated by Druid"

	| jump5 s24 s46 s16 jump3 s29 jump1 t1 s2 currentBlock s19 s27 jump6 live jump4 jump2 t2 jump7 t0 s48 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t0.
	(self ssValue: 0) copyToReg: t1.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1 popSpilled: true.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s16 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s16 R: t2.
	s19 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s19 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	s24 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s24 R: t2.
	s27 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s27 R: t2.
	jump5 := self JumpNonZero: 0.
	s29 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s29 R: t1.
	jump6 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self TstCq: 7 R: t1.
	jump6 := self JumpNonZero: 0.
	self CmpCq: 16r20000000000 R: t0.
	jump5 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump4 := self JumpGreaterOrEqual: 0.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t1.
	jump3 := self JumpBelow: 0.
	s46 := objectMemory trueObject.
	self CmpCq: s46 R: t1.
	jump1 := self JumpBelowOrEqual: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s48 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s48 R: t1.
	jump3 := self JumpBelow: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 M64: 64 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopRemoteTempLongBytecode [
	"AutoGenerated by Druid"

	| s6 s79 jump5 s46 jump3 s38 jump8 jump1 s75 t1 s2 currentBlock s51 s49 jump6 s73 jumpNext live s5 jumpTrue s3 t2 jump2 jump7 t0 s41 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	s3 := byte1.
	(self simStackTempAt: byte2) copyToReg: t0.
	s5 := TempVectReadBarrier.
	s5 ifTrue: [
		| jump1 b557 jumpNext jump6 jump3 jump8 jump5 jumpTrue jump2 jump7 jump4 |
		self MoveM64: 0 r: t0 R: t1.
		self AndCq: 16r3FFFF7 R: t1.
		self CmpCq: 0 R: t1.
		jump1 := self JumpNonZero: 0.
		self MoveM64: 8 r: t0 R: t1.
		b557 := self Label.
		self MoveR: t1 R: t0.
		self AndCq: 7 R: t0.
		self CmpCq: 0 R: t0.
		jump2 := self JumpNonZero: 0.
		self MoveM64: 0 r: t1 R: t0.
		self AndCq: 16r3FFFF7 R: t0.
		self CmpCq: 0 R: t0.
		jump3 := self JumpNonZero: 0.
		self MoveM64: 8 r: t1 R: t0.
		self MoveR: t0 R: t1.
		jump4 := self Jump: b557.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		self MoveR: t1 R: t0.
		jump3 := self Jump: 0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		(self ssValue: 0) copyToReg: t1.
		self MoveR: t0 R: t2.
		self AndCq: 7 R: t2.
		self ssFlushStack.
		self CmpCq: 0 R: t2.
		jump3 := self JumpNonZero: 0.
		s38 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveR: t0 R: t2.
		self AndCq: s38 R: t2.
		s41 := objectMemory getMemoryMap getOldSpaceMask.
		self CmpCq: s41 R: t2.
		jump1 := self JumpNonZero: 0.
		self MoveR: t1 R: t2.
		self AndCq: 7 R: t2.
		self CmpCq: 0 R: t2.
		jump2 := self JumpNonZero: 0.
		s46 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveR: t1 R: t2.
		self AndCq: s46 R: t2.
		s49 := objectMemory getMemoryMap getNewSpaceMask.
		self CmpCq: s49 R: t2.
		jump5 := self JumpNonZero: 0.
		s51 := objectMemory getMemoryMap getNewSpaceStart.
		self MoveR: t1 R: t2.
		self CmpCq: s51 R: t2.
		jumpTrue := self JumpAboveOrEqual: 0.
		self MoveCq: 0 R: t2.
		jumpNext := self Jump: 0.
		jumpTrue jmpTarget: self Label.
		self MoveCq: 1 R: t2.
		jumpNext jmpTarget: self Label.
		self CmpCq: 1 R: t2.
		jump6 := self JumpNonZero: 0.
		self MoveM64: 0 r: t0 R: t2.
		self LogicalShiftRightCq: 29 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump7 := self JumpNonZero: 0.
		self MoveR: t0 R: TempReg.
		backEnd saveAndRestoreLinkRegAround: [
			self CallRT: ceStoreCheckTrampoline ].
		jump8 := self Jump: 0.
		currentBlock := self Label.
		jump5 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		jump1 jmpTarget: currentBlock.
		jump2 jmpTarget: currentBlock.
		jump6 jmpTarget: currentBlock.
		jump7 jmpTarget: currentBlock.
		jump8 jmpTarget: currentBlock.
		self MoveM64: 0 r: t0 R: t2.
		self LogicalShiftRightCq: 29 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump8 := self JumpNonZero: 0.
		self TstCq: 7 R: t1.
		jump7 := self JumpNonZero: 0.
		self CmpCq: 16r20000000000 R: t0.
		jump6 := self JumpLess: 0.
		self CmpCq: 16r20000000000 R: t1.
		jump2 := self JumpGreaterOrEqual: 0.
		self genMoveConstant: objectMemory nilObject R: t2.
		self CmpR: t2 R: t1.
		jump1 := self JumpBelow: 0.
		s73 := objectMemory trueObject.
		self CmpCq: s73 R: t1.
		jump3 := self JumpBelowOrEqual: 0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		s75 := objectMemory getMemoryMap getNewSpaceStart.
		self CmpCq: s75 R: t1.
		jump1 := self JumpBelow: 0.
		self MoveR: t0 R: TempReg.
		backEnd saveAndRestoreLinkRegAround: [
			self CallRT: ceStoreCheckTrampoline ].
		currentBlock := self Label.
		jump8 jmpTarget: currentBlock.
		jump7 jmpTarget: currentBlock.
		jump6 jmpTarget: currentBlock.
		jump2 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		jump1 jmpTarget: currentBlock.
		s79 := s3 << 3.
		self AddCq: s79 R: t0.
		self MoveR: t1 M64: 8 r: t0.
		self ssPop: 1 popSpilled: true.
		^ 0 ].
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s38 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s38 R: t2.
	s41 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s41 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	s46 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s46 R: t2.
	s49 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s49 R: t2.
	jump6 := self JumpNonZero: 0.
	s51 := objectMemory getMemoryMap getNewSpaceStart.
	self MoveR: t1 R: t2.
	self CmpCq: s51 R: t2.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump8 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump5 := self JumpNonZero: 0.
	self TstCq: 7 R: t1.
	jump8 := self JumpNonZero: 0.
	self CmpCq: 16r20000000000 R: t0.
	jump7 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump2 := self JumpGreaterOrEqual: 0.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t1.
	jump3 := self JumpBelow: 0.
	s73 := objectMemory trueObject.
	self CmpCq: s73 R: t1.
	jump1 := self JumpBelowOrEqual: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s75 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s75 R: t1.
	jump3 := self JumpBelow: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	s79 := s3 << 3.
	self AddCq: s79 R: t0.
	self MoveR: t1 M64: 8 r: t0.
	self ssPop: 1 popSpilled: true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopTemporaryVariableBytecode0 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssFlushUpThroughTemporaryVariable: 0.
	self MoveR: t0 Mw: (self frameOffsetOfTemporary: 0) r: FPReg.
	self ssPop: 1 popSpilled: true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopTemporaryVariableBytecode1 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssFlushUpThroughTemporaryVariable: 1.
	self MoveR: t0 Mw: (self frameOffsetOfTemporary: 1) r: FPReg.
	self ssPop: 1 popSpilled: true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopTemporaryVariableBytecode2 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssFlushUpThroughTemporaryVariable: 2.
	self MoveR: t0 Mw: (self frameOffsetOfTemporary: 2) r: FPReg.
	self ssPop: 1 popSpilled: true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopTemporaryVariableBytecode3 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssFlushUpThroughTemporaryVariable: 3.
	self MoveR: t0 Mw: (self frameOffsetOfTemporary: 3) r: FPReg.
	self ssPop: 1 popSpilled: true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopTemporaryVariableBytecode4 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssFlushUpThroughTemporaryVariable: 4.
	self MoveR: t0 Mw: (self frameOffsetOfTemporary: 4) r: FPReg.
	self ssPop: 1 popSpilled: true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopTemporaryVariableBytecode5 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssFlushUpThroughTemporaryVariable: 5.
	self MoveR: t0 Mw: (self frameOffsetOfTemporary: 5) r: FPReg.
	self ssPop: 1 popSpilled: true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopTemporaryVariableBytecode6 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssFlushUpThroughTemporaryVariable: 6.
	self MoveR: t0 Mw: (self frameOffsetOfTemporary: 6) r: FPReg.
	self ssPop: 1 popSpilled: true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopTemporaryVariableBytecode7 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssFlushUpThroughTemporaryVariable: 7.
	self MoveR: t0 Mw: (self frameOffsetOfTemporary: 7) r: FPReg.
	self ssPop: 1 popSpilled: true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreRemoteTempLongBytecode [
	"AutoGenerated by Druid"

	| s6 s79 jump5 s46 jump3 s38 jump8 jump1 s75 t1 s2 currentBlock s51 s49 jump6 s73 jumpNext live s5 jumpTrue s3 t2 jump2 jump7 t0 s41 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self annotateBytecode: self Label.
	s3 := byte1.
	(self simStackTempAt: byte2) copyToReg: t0.
	s5 := TempVectReadBarrier.
	s5 ifTrue: [
		| jump1 jumpNext b551 jump6 jump3 jump8 jump5 jumpTrue jump2 jump7 jump4 |
		self MoveM64: 0 r: t0 R: t1.
		self AndCq: 16r3FFFF7 R: t1.
		self CmpCq: 0 R: t1.
		jump1 := self JumpNonZero: 0.
		self MoveM64: 8 r: t0 R: t1.
		b551 := self Label.
		self MoveR: t1 R: t0.
		self AndCq: 7 R: t0.
		self CmpCq: 0 R: t0.
		jump2 := self JumpNonZero: 0.
		self MoveM64: 0 r: t1 R: t0.
		self AndCq: 16r3FFFF7 R: t0.
		self CmpCq: 0 R: t0.
		jump3 := self JumpNonZero: 0.
		self MoveM64: 8 r: t1 R: t0.
		self MoveR: t0 R: t1.
		jump4 := self Jump: b551.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		self MoveR: t1 R: t0.
		jump3 := self Jump: 0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		(self ssValue: 0) copyToReg: t1.
		self MoveR: t0 R: t2.
		self AndCq: 7 R: t2.
		self ssFlushStack.
		self CmpCq: 0 R: t2.
		jump3 := self JumpNonZero: 0.
		s38 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveR: t0 R: t2.
		self AndCq: s38 R: t2.
		s41 := objectMemory getMemoryMap getOldSpaceMask.
		self CmpCq: s41 R: t2.
		jump1 := self JumpNonZero: 0.
		self MoveR: t1 R: t2.
		self AndCq: 7 R: t2.
		self CmpCq: 0 R: t2.
		jump2 := self JumpNonZero: 0.
		s46 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveR: t1 R: t2.
		self AndCq: s46 R: t2.
		s49 := objectMemory getMemoryMap getNewSpaceMask.
		self CmpCq: s49 R: t2.
		jump5 := self JumpNonZero: 0.
		s51 := objectMemory getMemoryMap getNewSpaceStart.
		self MoveR: t1 R: t2.
		self CmpCq: s51 R: t2.
		jumpTrue := self JumpAboveOrEqual: 0.
		self MoveCq: 0 R: t2.
		jumpNext := self Jump: 0.
		jumpTrue jmpTarget: self Label.
		self MoveCq: 1 R: t2.
		jumpNext jmpTarget: self Label.
		self CmpCq: 1 R: t2.
		jump6 := self JumpNonZero: 0.
		self MoveM64: 0 r: t0 R: t2.
		self LogicalShiftRightCq: 29 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump7 := self JumpNonZero: 0.
		self MoveR: t0 R: TempReg.
		backEnd saveAndRestoreLinkRegAround: [
			self CallRT: ceStoreCheckTrampoline ].
		jump8 := self Jump: 0.
		currentBlock := self Label.
		jump5 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		jump1 jmpTarget: currentBlock.
		jump2 jmpTarget: currentBlock.
		jump6 jmpTarget: currentBlock.
		jump7 jmpTarget: currentBlock.
		jump8 jmpTarget: currentBlock.
		self MoveM64: 0 r: t0 R: t2.
		self LogicalShiftRightCq: 29 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump8 := self JumpNonZero: 0.
		self TstCq: 7 R: t1.
		jump7 := self JumpNonZero: 0.
		self CmpCq: 16r20000000000 R: t0.
		jump6 := self JumpLess: 0.
		self CmpCq: 16r20000000000 R: t1.
		jump2 := self JumpGreaterOrEqual: 0.
		self genMoveConstant: objectMemory nilObject R: t2.
		self CmpR: t2 R: t1.
		jump1 := self JumpBelow: 0.
		s73 := objectMemory trueObject.
		self CmpCq: s73 R: t1.
		jump3 := self JumpBelowOrEqual: 0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		s75 := objectMemory getMemoryMap getNewSpaceStart.
		self CmpCq: s75 R: t1.
		jump1 := self JumpBelow: 0.
		self MoveR: t0 R: TempReg.
		backEnd saveAndRestoreLinkRegAround: [
			self CallRT: ceStoreCheckTrampoline ].
		currentBlock := self Label.
		jump8 jmpTarget: currentBlock.
		jump7 jmpTarget: currentBlock.
		jump6 jmpTarget: currentBlock.
		jump2 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		jump1 jmpTarget: currentBlock.
		s79 := s3 << 3.
		self AddCq: s79 R: t0.
		self MoveR: t1 M64: 8 r: t0.
		^ 0 ].
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s38 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s38 R: t2.
	s41 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s41 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	s46 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s46 R: t2.
	s49 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s49 R: t2.
	jump6 := self JumpNonZero: 0.
	s51 := objectMemory getMemoryMap getNewSpaceStart.
	self MoveR: t1 R: t2.
	self CmpCq: s51 R: t2.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump8 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump5 := self JumpNonZero: 0.
	self TstCq: 7 R: t1.
	jump8 := self JumpNonZero: 0.
	self CmpCq: 16r20000000000 R: t0.
	jump7 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump2 := self JumpGreaterOrEqual: 0.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t1.
	jump3 := self JumpBelow: 0.
	s73 := objectMemory trueObject.
	self CmpCq: s73 R: t1.
	jump1 := self JumpBelowOrEqual: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s75 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s75 R: t1.
	jump3 := self JumpBelow: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	s79 := s3 << 3.
	self AddCq: s79 R: t0.
	self MoveR: t1 M64: 8 r: t0.
	^ 0
]
