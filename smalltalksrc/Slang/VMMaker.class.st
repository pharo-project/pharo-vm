"
This class coordinates generating sources for the various VMs and the set of plugins that comprise the Cog VM.  See the class side for generating all or some configurations.  The source is intended to be generated in the context of the opensmalltalk-vm source tree available via git from https://github.com/OpenSmalltalk/opensmalltalk-vm.  See VMMaker class>>initialize for the relative locations of this image and the source tree (for example, in the image directory of the opensmalltalk-vm tree).  Invoke a single configuration via e.g.
	VMMaker generateSqueakSpurCog64VM
or a set via e.g.
	VMMaker generateAllConfigurationsUnderVersionControl

The source tree on branch Cog at https://github.com/OpenSmalltalk/opensmalltalk-vm is generated via generateAllConfigurationsUnderVersionControl.  Note that ""Squeak"" in these cofiguarations means virtual machines that support various versions of Squeak, Pharo and Cuis smalltalks.  IIABDFI.


Words to the wise:
In the old days, VM sources would be generated per-platform.  Now, all the source generated by the above generators and included in https://github.com/OpenSmalltalk/opensmalltalk-vm is separately versioned, and we use only CrossPlatformVMMaker to generate them.  All platform-specific variations, such as whether to use a struct to hold the interpreter's global variables, which plugins to include in a VM, etc, are included in the generated osurce.  All plugins are generated such that they can be compiled as either internal or external plugins.  What specific variations to use are therefore controlled by the platform-specific makefiles, and the decision is deferred from source generation time to VM build time.  The source is designed to be platform neutral.  This form is chosen carefully to allow VMs to be built from fully checked-in, and hence fully versioned source.


Old commentary:
This class builds a VM codebase from the in-image and on-file code.

The platforms file tree you need can be downloaded via cvs from http://squeak.Sourceforge.net. See also the swiki (http://minnow.cc.gatech.edu/squeak/2106) for instructions.

It is fairly configurable as to where directories live and can handle multiple platform's source trees at once. It's main purpose is to allow easy building of source trees with any combination of internal/external/unused plugins to suit your platform needs and capabilities. For example, the Acorn has no need of Sound or AsynchFile plugins since I haven't written any platform code for them. 

There is a simple UI tool for this 
	VMMakerTool openInWorld
will open a reasonably self explanatory tool with balloon help to explain all the fields - and a help window on top of that.

There are some simple workspace & inspector commands, allowing scripted building:
	VMMaker default initializeAllExternal generateEntire
for example will build sources for a system with all the plugins external whereas 
	VMMaker default initializeAllInternal generateEntire
would build all applicable plugins for internal compilation.
	(VMMaker forPlatform: 'Mac OS') initializeAllExternal generateEntire
would build a source tree for a Mac even on a Windows machine (err, ignoring for now the irritation of lineends).

	If you have a slightly more complex configuration you want to use, perhaps with Socket and Serial support external (because for your case they are rarely used and saving the space has some value) then you could try
		(VMMaker default initializeAllInternalBut: #(SocketPlugin SerialPlugin) generateEntire
	More complex still would be
		(VMMaker default initializeInternal: #(BitBltPlugin MiscPrimsPlugin FilePlugin) external: #(SocketPlugin ZipPlugin B2DPlugin)
which allows you to precisely list all the plugins to use.

WARNING If you miss out a plugin you need, it won't be there. This message is really best suited to use by a UI like VMMakerTool.

	To save a configuration for later use, you need to send #saveConfiguration to an active instance of VMMaker. Obviously you could simply use
		(VMMaker default initializeAllInternalBut: #(SocketPlugin SerialPlugin) saveConfiguration
but inspecting 
		VMMaker default
and altering the internalPlugins and externalPlugins or the boolean flags for inline or forBrowser followed by saving the configuration allows ultimate power for now. To load a saved configuration file, use #loadConfigurationFrom: aFilename whilst inspecting a VMMaker. The loaded state will completely override any pre-existing state, so take care.
	You can generate only parts of the source tree if you wish; as shown above #generateEntire will create the whole collection of internal and external plugins as well as the core VM. To create only  the external plugins use #generateExternalPlugins, or create a single  plugin with #generateExternalPlugin: name. To assemble the main VM including the internal plugins, use #generateMainVM. The interpreter 'interp.c' file is made with #generateInterpreterFile. You can generate a single internal plugin with #generateInternalPlugin: only if it has already been generated before; this interlocking is intended to make sure the named primitive table in the vm is correct.

There are some rules to observe in order to use this:-
- under the working directory (by default - you can configure it) you need a directory called 'platforms' (also configurable) with subdirectories named as the platform names returned by Smalltalk platformName (ie unix, RiscOS, Mac OS, etc - this isn't configurable). At the very least you need the one for your own platform and the pseudo-platform called 'Cross'. By adding a 'DirNames' entry for #machineType you can cross 'compile' for some other platform. Now all we need is a cross-compiler for the C code :-)
- under this directory you must have a simple structure of directories for each generated plugin that you support on the platform, plus 'vm'. In each directory you place any/all platform specific files (and subdirectories) for that plugin. In 'misc' you can place any miscellaneous files such as makefiles, resources etc. For example, for unix you have
	platforms/
		unix/
			plugins/
				AsynchFilePlugin /
					sqUnixAsynchfile.c
			vm/
				sqGnu.h
				Profile/
			misc/
				makefile.in
				util/
				
				...etc
Any plugins requiring platform files that you don't support shouldn't appear in the resulting code tree. If you try to include an unsupported plugin in the list to be made external, the VMMaker simply ignores it. However, if you include it in the list to be made internal you will get an error since that seems like a potentially serious source of confusion.

There are three lists of plugins maintained herein:-
1) the list of all known generatable plugins. We scan this list and compare with the supported plugins as indicated by the file tree.
2) the list of chosen internal plugins.
3) the list of chosen external plugins.
See initializeAllPlugins, initialiseAllExternal etc for fairly obvious usage.
There is also a short list of directory names in the class variable 'DirNames' that you can alter if needed.

Known problems:-
a) since Squeak has really poor filename handling, you can't simply change the directory names to '/foo/bar/myEvilCodeBase' and expect it to work. You fix file names and I'll fix VMMaker :-)
b) Squeak copying of a file loses the assorted permissions, filetype info and other useful bits. To workaround this problem, see the FileCopyPlugin, which provides the platform independent part of a simple access for the OS filecopy capability. So far there are functional plugins for unix, Mac and Acorn. DOS machines appear not to need one. This is less of a problem in practise now that unix, Acorn & Mac no longer copy files from /platforms to /src.

inline <Boolean> - is the generated code to be inlined or not
forBrowser <Boolean> - is this to be a build for in-Browser use? Only relevent to Macs
allPlugins <Collection> - all the known possible plugins
internalPlugins <Collection> - the plugins chosen to be generated for internal linking
externalPlugins <Collection> - the plugins intended to be external plugins
exportList <Collection> - a list of function names exported from plugins intended to be internal
platformName <String> - the name of the platform for which we are building a source tree. It is possible to do 'cross-compiles'
sourceDirName, platformRootDirName <String> - the name of the directory into which we write the generated sources and the name of the directory where we should find the platforms tree.
"
Class {
	#name : 'VMMaker',
	#superclass : 'Object',
	#instVars : [
		'inline',
		'forBrowser',
		'allPlugins',
		'internalPlugins',
		'externalPlugins',
		'platformName',
		'sourceDirName',
		'platformRootDirName',
		'logger',
		'interpreterClassName',
		'is64BitVM',
		'optionsDictionary',
		'abortBlock',
		'doCleanupOldFiles',
		'silently',
		'vmmakerConfiguration',
		'stopOnErrors'
	],
	#category : 'Slang-Core',
	#package : 'Slang',
	#tag : 'Core'
}

{ #category : 'initialisation' }
VMMaker class >> activeVMMakerClassFor: platformName [
	"Return the concrete VMMaker subclass for the platform on which we are currently running."

	VMMaker allSubclasses do: [:class |
		(class isActiveVMMakerClassFor: platformName) ifTrue: [^ class]].

	"no responding subclass; use VMMaker"
	^ VMMaker

]

{ #category : 'confs-support' }
VMMaker class >> configurationNameFromSelector: aSelector [
	^(aSelector piecesCutWhere: [:a :b| a isLowercase and: [b isUppercase]]) allButFirst fold: [:a :b| a, ' ', b]
]

{ #category : 'instance creation' }
VMMaker class >> forPlatform: platformName [
	"return a VMMaker initialised to build a default no-internal-plugins, no-external-plugins vm codebase"
	^(self activeVMMakerClassFor: platformName) new setPlatName: platformName
]

{ #category : 'file utilities' }
VMMaker class >> forceNewFileNamed: aFilename [
	"Always output files in unix lf format.
		A single format is friendlier to e.g. external version control systems.
		The Microsoft and old MacOS classic C compilers all accept lf format files."

	| inner |
	aFilename asFileReference ensureDelete.
	inner := aFilename asFileReference writeStream.
	
	^ (ZnNewLineWriterStream on: inner)
		forLf;
		yourself


]

{ #category : 'file utilities' }
VMMaker class >> fullNameForPath: aPathString [

	^ aPathString asFileReference asAbsolute fullName
]

{ #category : 'utilities' }
VMMaker class >> generate: interpreterClass and: cogitClass with: optionsPairsArray to: srcDirName platformDir: platDirName including: inclusions configuration: vmmakerConfiguration [
	"Generate the VM to the given target directory. Include only plugins in pluginList.
	 Example:
		(VMMaker
			generate: CoInterpreter
			and: SimpleStackBasedCogit
			to: (FileDirectory default pathFromURI: '../src')
			platformDir: (FileDirectory default pathFromURI: '../platforms')
			including:#(	AsynchFilePlugin FloatArrayPlugin RePlugin B2DPlugin FloatMathPlugin SecurityPlugin
						BMPReadWriterPlugin IA32ABI SocketPlugin BitBltPlugin JPEGReadWriter2Plugin SurfacePlugin
						DSAPrims JPEGReaderPlugin UUIDPlugin DropPlugin LargeIntegers UnixOSProcessPlugin
						FileCopyPlugin Matrix2x3Plugin Win32OSProcessPlugin FilePlugin MiscPrimitivePlugin ZipPlugin))"
	(self
		makerFor: interpreterClass
		and: cogitClass
		with: optionsPairsArray
		to: srcDirName
		platformDir: platDirName
		including: inclusions
		configuration: vmmakerConfiguration) generateEntire
]

{ #category : 'initialisation' }
VMMaker class >> isActiveVMMakerClassFor: platformName [ 
	"Does this class claim to be that properly active subclass of VMMaker for 
	this platform? Subclasses are welcome to override this default"
	^ platformName , '*' match: self name
]

{ #category : 'instance creation' }
VMMaker class >> makerFor: interpreterClass and: cogitClassOrNil with: optionsPairsArray to: srcDirName platformDir: platDirName configuration: vmmakerConfiguration [
	"Initialize a VMMaker to generate the VM to the given target directory."
	| options|
	
	options := Dictionary newFromPairs: optionsPairsArray.
	
	(cogitClassOrNil isNil or: [ options includes: #Cogit ])
		ifFalse: [ options at: #Cogit put: cogitClassOrNil name ].
		
	(self environment at: (options at: #ObjectMemory)) initializeWithOptions: options.
		
	vmmakerConfiguration initializeForPlugins: options.
	
	^(self forPlatform: 'Cross')
		vmmakerConfiguration: vmmakerConfiguration;
		sourceDirectoryName: (self fullNameForPath: srcDirName);
		platformRootDirectoryName: (self fullNameForPath: platDirName);
		options: options;
		interpreterClass: interpreterClass;
		yourself
]

{ #category : 'instance creation' }
VMMaker class >> makerFor: interpreterClass and: cogitClassOrNil with: optionsPairsArray to: srcDirName platformDir: platDirName including: inclusions configuration: vmclassConfiguration [
	"Initialize a VMMaker to generate the VM to the given target directory. Include plugins in pluginList.
	Example:
		(VMMaker
			generate: NewspeakInterpreter
			to: (FileDirectory default pathFromURI: 'cogvm/newspeaksrc')
			platformDir: (FileDirectory default pathFromURI: 'cogvm/platforms')
			including:#(	AsynchFilePlugin FloatArrayPlugin RePlugin B2DPlugin FloatMathPlugin SecurityPlugin
						BMPReadWriterPlugin IA32ABI SocketPlugin BitBltPlugin JPEGReadWriter2Plugin SurfacePlugin
						DSAPrims JPEGReaderPlugin UUIDPlugin DropPlugin LargeIntegers UnixOSProcessPlugin
						FileCopyPlugin Matrix2x3Plugin Win32OSProcessPlugin FilePlugin MiscPrimitivePlugin ZipPlugin))"
	| maker |
	maker := self makerFor: interpreterClass and: cogitClassOrNil with: optionsPairsArray to: srcDirName platformDir: platDirName configuration: vmclassConfiguration.
	maker externalModules addAll: inclusions.
	^maker
	
]

{ #category : 'file utilities' }
VMMaker class >> rootDirectory [
	^ self sourceTree asFileReference
]

{ #category : 'accessing' }
VMMaker >> abortBlock [
	^abortBlock
]

{ #category : 'plugin lists' }
VMMaker >> allModuleNames [
	"return the list of all the all plugins' moduleNames"
	^Array streamContents:[:strm| self allPluginsDo:[:pl| strm nextPut: pl moduleName ]]
]

{ #category : 'plugin lists' }
VMMaker >> allPluginsDo: aBlock [ 
	"for each class that should be an external plugin, evaluate aBlock"
	self externalPluginsDo: aBlock.
	self internalPluginsDo: aBlock.
]

{ #category : 'UI access' }
VMMaker >> availablePlugins [
	allPlugins ifNil:[self initializeAllPlugins].
	^allPlugins
]

{ #category : 'generate sources' }
VMMaker >> buildCodeGeneratorForCogit [
	"Answer the code generator for translating the cogit."

	^(Smalltalk classNamed: #CurrentReadOnlySourceFiles)
		ifNil: [self
				buildCodeGeneratorForCogit: self interpreterClass cogitClass
				includeAPIMethods: true
				initializeClasses: true]
		ifNotNil:
			[:crosf|
			 crosf cacheDuring:
				[self
					buildCodeGeneratorForCogit: self interpreterClass cogitClass
					includeAPIMethods: true
					initializeClasses: true]]
]

{ #category : 'generate sources' }
VMMaker >> buildCodeGeneratorForCogit: cogitClass includeAPIMethods: getAPIMethods initializeClasses: initializeClasses [
	"Answer the code generator for translating the cogit."

	| cg cogitClasses |
	cg := self createCogitCodeGenerator.

	cg vmClass: cogitClass.
	initializeClasses ifTrue:
		[{ cogitClass. self interpreterClass. self interpreterClass objectMemoryClass } do:
			[:cgc|
			(cgc respondsTo: #initializeWithOptions:)
				ifTrue: [cgc initializeWithOptions: optionsDictionary]
				ifFalse: [cgc initialize]]].

	cogitClasses := OrderedCollection withAll: (cogitClass withAllSuperclasses copyUpThrough: SlangClass) reverse.
	cogitClasses addAllLast: (cogitClass ancilliaryClasses reject: [:class| class isStructClass]).
	cogitClasses do: [:cgc| cg addClass: cgc].
	"Now make sure to add struct classes that the most specific subclasses specify.
	 This makes sure that struct classes are ordered as the most specific cogitClass desires.
	 This must happen for references between the struct classes to be resolved in a specific order."
	cogitClasses := OrderedCollection with: cogitClass with: cogitClass objectRepresentationClass.
	cogitClasses addAll: (cogitClass ancilliaryClasses reject:
							[:class|
							 class isStructClass
							 or: [cogitClass objectRepresentationClass includesBehavior: class]]).
	cg addStructClasses: (cg structClassesForTranslationClasses: cogitClasses).

	getAPIMethods ifTrue:
		[cg includeAPIFrom: (self
								buildCodeGeneratorForInterpreter: self interpreterClass
								includeAPIMethods: false
								initializeClasses: false)].

	^cg
]

{ #category : 'generate sources' }
VMMaker >> buildCodeGeneratorForInterpreter [
	"Answer the code generator for translating the interpreter."

	^(Smalltalk classNamed: #CurrentReadOnlySourceFiles)
		ifNil: [self
				buildCodeGeneratorForInterpreter: self interpreterClass
				includeAPIMethods: true
				initializeClasses: true]
		ifNotNil:
			[:crosf|
			 crosf cacheDuring:
				[self
					buildCodeGeneratorForInterpreter: self interpreterClass
					includeAPIMethods: true
					initializeClasses: true]]
]

{ #category : 'generate sources' }
VMMaker >> buildCodeGeneratorForInterpreter: interpreterClass includeAPIMethods: getAPIMethods initializeClasses: initializeClasses [

	"Answer the code generator for translating the interpreter."

	| cg interpreterClasses |
	initializeClasses ifTrue: [ 
		interpreterClass initializeWithOptions: optionsDictionary.
		interpreterClass hasCogit ifTrue: [ 
			interpreterClass cogitClass initializeWithOptions:
				optionsDictionary ] ].

	(cg := self createCodeGenerator) vmClass: interpreterClass.

	"Construct interpreterClasses as all classes from interpreterClass &
	 objectMemoryClass up to VMClass in superclass to subclass order."
	interpreterClasses := OrderedCollection new.
	{ 
		interpreterClass.
		interpreterClass objectMemoryClass } do: [ :vmClass | 
		| theClass |
		theClass := vmClass.
		[ theClass ~~ self vmmakerConfiguration baseClass ] whileTrue: [ 
			interpreterClasses addFirst: theClass.
			theClass := theClass superclass ] ].
	interpreterClasses
		addFirst: self vmmakerConfiguration baseClass;
		addAllLast:
			(cg nonStructClassesForTranslationClasses: interpreterClasses).

	initializeClasses ifTrue: [ 
		interpreterClasses do: [ :ic | 
			(ic respondsTo: #initializeWithOptions:)
				ifTrue: [ 
				ic initializeWithOptions: interpreterClass initializationOptions ]
				ifFalse: [ ic initialize ] ].
		(cg structClassesForTranslationClasses: interpreterClasses) do: [ 
			:structClass | structClass initialize ] ].

	cg addStructClasses:
		(cg structClassesForTranslationClasses: interpreterClasses).

	interpreterClasses do: [ :ic | cg addClass: ic ].

	getAPIMethods ifTrue: [ 
		interpreterClass cogitClass ifNotNil: [ :cogitClass | 
			cg includeAPIFrom: (self
					 buildCodeGeneratorForCogit: cogitClass
					 includeAPIMethods: false
					 initializeClasses: false) ] ].

	^ cg
]

{ #category : 'plugin lists' }
VMMaker >> canSupportPlugin: pluginClassName [ 
	"see if this plugin needs any external files and if so, check to see if 
	they seem to exist."
	[self validatePlugin: pluginClassName in: allPlugins , internalPlugins , externalPlugins]
		on: VMMakerException
		do: [^ false].
	^ true
]

{ #category : 'generate sources' }
VMMaker >> configurationGeneratorNameOrNil [
	"Search the sender chain for the first method in VMMaker class protocol configurations, and answer it if found,
	 otherwise answer nil.  This allows us to name the configuration being generated."
	^thisContext findContextSuchThat:
		[:ctxt|
		 ctxt receiver == VMMaker
		 and: [ctxt method methodReference category = #configurations]]
]

{ #category : 'generate sources' }
VMMaker >> configurationNameIfAny [
	^self configurationGeneratorNameOrNil
		ifNotNil: [:ctxt| (self class configurationNameFromSelector: ctxt selector), ' ']
		ifNil: [' ']
]

{ #category : 'target directories' }
VMMaker >> coreVMDirectory [
	"return the target directory for the main VM sources, interp.c etc"
	^ (self sourceDirectory / self vmmakerConfiguration coreVMDirName)
		ensureCreateDirectory;
		yourself.

]

{ #category : 'target directories' }
VMMaker >> coreVMHeadersDirectory [
	"return the target directory for the main VM sources, interp.c etc"
	| fd |
	fd := self sourceDirectory / self vmmakerConfiguration coreVMHeadersDirName.
	fd ensureCreateDirectory.
	^ fd
]

{ #category : 'private - errors' }
VMMaker >> couldNotFindDirectory: dirName [
	"This should raise a nice exception to a UI"
	^(VMMakerException new messageText: self class name, ' could not find directory ', dirName) signal
]

{ #category : 'private - errors' }
VMMaker >> couldNotFindPlatformDirectoryFor: platName [
	"This should raise a nice exception to a UI"
	self couldNotFindDirectory: 'for: ', platName, ' specific files; is the platform root path set correctly?'
]

{ #category : 'private - errors' }
VMMaker >> couldNotFindPlatformFilesFor: plugin [
	"This should raise a nice exception to a UI"
	(VMMakerException new messageText: self class name, ' could not find platform specific files for: ', plugin moduleName) signal
]

{ #category : 'private - errors' }
VMMaker >> couldNotFindPluginClass: pluginSymbol [
	"This should raise a nice exception to a UI"
	(VMMakerException new messageText: self class name, ' could not find the class for: ', pluginSymbol) signal
]

{ #category : 'private - errors' }
VMMaker >> couldNotOpenFile: fileName [
	"This should raise a nice exception to a UI"
	(VMMakerException new messageText: self class name, ' could not open file: ', fileName) signal
]

{ #category : 'source directories' }
VMMaker >> crossPlatformDirectory [
	"return the directory where we should find the cross-platform literal 
	sources - <sq.h> etc"
	| dir |
	dir := self platformRootDirectory directoryNamed: 'Cross'.
	dir exists ifFalse: "The supposed directory for the actual cross-platform code does not exist."
		[^self couldNotFindPlatformDirectoryFor: 'cross-platform '].
	^dir
]

{ #category : 'source directories' }
VMMaker >> crossPlatformPluginsDirectory [
	"return the directory where we should find the cross-platform plugin specific sources"
	| dir |
	dir := self crossPlatformDirectory directoryNamed: self class pluginsDirName.
	dir exists ifFalse: "The supposed directory for the plugins code does not exist.
					  We need to raise a suitable exception, but can't think of one right now."
		[^self couldNotFindPlatformDirectoryFor: 'any plugins needing cross-platform'].
	^dir
]

{ #category : 'target directories' }
VMMaker >> deleteEntireGeneratedTree [
	"remove all the files - all of them I say"
	self sourceDirectory recursiveDelete
]

{ #category : 'target directories' }
VMMaker >> deleteUnwantedExternalPluginDirectories [
	"don't. in real life people back plugin directories with source code controls and simply deleting them really doesn't help."
]

{ #category : 'target directories' }
VMMaker >> deleteUnwantedInternalPluginDirectories [
	"don't. in real life people back plugin directories with source code controls and simply deleting them really doesn't help."
]

{ #category : 'initialize' }
VMMaker >> doCleanupOldFiles [

	doCleanupOldFiles := true
]

{ #category : 'generate sources' }
VMMaker >> doInlining [
	"default is true but see VMMaker>initialize for details"
	^inline
]

{ #category : 'exports' }
VMMaker >> export: exportList forExternalPlugin: aPlugin [
"it may be useful on certain platforms to do something with the export list of external plugins, just as the internal plugins' exports get added to the VM list. Default is to do nothing though."
]

{ #category : 'UI access' }
VMMaker >> externalModules [
	^externalPlugins
]

{ #category : 'target directories' }
VMMaker >> externalPluginListName [
	"Answer the filename for the list of external plugins"

	^'plugins.ext'
]

{ #category : 'target directories' }
VMMaker >> externalPluginsDirectory [
	"return the target directory for the external plugins sources"
	^ (self sourceDirectory / self vmmakerConfiguration pluginsDirName)
		ensureCreateDirectory;
		yourself. 
]

{ #category : 'target directories' }
VMMaker >> externalPluginsDirectoryFor: plugin [
	"return the directory for the external plugin sources"
	
	^ (self externalPluginsDirectory / plugin moduleName)
		ensureCreateDirectory;
		yourself

]

{ #category : 'plugin lists' }
VMMaker >> externalPluginsDo: aBlock [ 
	"for each class that should be an external plugin, evaluate aBlock"
	self plugins: externalPlugins do: aBlock
]

{ #category : 'initialize' }
VMMaker >> for32BitVM [
"set my flag to make a 32bit pointer model VM"
	is64BitVM := false.
	self changed: #sourcePathText.
]

{ #category : 'initialize' }
VMMaker >> for64BitVM [
"set my flag to make a 64bit pointer model VM"
	is64BitVM := true.
	self changed: #sourceDirectory.
]

{ #category : 'headers' }
VMMaker >> generateAdditionalHeadersFor: aClass withCodeGenerator: cg [

	aClass additionalHeadersDo: [:headerName :headerContents| | filePath |
		 filePath := (self coreVMHeadersDirectory / headerName) fullName.
		 (cg needToGenerateHeader: headerName file: filePath contents: headerContents) ifTrue:
			 [cg storeHeaderOnFile: filePath contents: headerContents]].
]

{ #category : 'generate sources' }
VMMaker >> generateCogitFileFor: cogitClass [
	"Translate the Smalltalk description of the Cogit into C, if required.  Ensure that
	 inferTypesForImplicitlyTypedVariablesAndMethods was done, and answer the code generator."

	| cg |
	cg := self buildCodeGeneratorForCogit.

	cg inferTypes.
	self needsToRegenerateCogitFile ifFalse: [^cg].

	cg vmClass preGenerationHook: cg.
	cg storeCodeOnFile: (self sourceFilePathFor: cogitClass processorSpecificSourceFileName) doInlining: cogitClass doInlining.
	^cg
]

{ #category : 'generate sources' }
VMMaker >> generateCogitFiles [
	"Translate the Smalltalk description of the virtual machine's JITs into C."
	| cogitClass cg |
	(cogitClass := self interpreterClass cogitClass) ifNil: [^nil].
	self generateCogitIncludeFileFor: cogitClass.
	cogitClass translateableInstructionSubclassesAndInstalledOptionsDo:
		[:compilerClass|
		cg := self generateCogitFileFor: cogitClass].

	self generateAdditionalHeadersFor: cg vmClass withCodeGenerator: cg.

	cogitClass apiExportHeaderName ifNotNil:
		[cg storeAPIExportHeader: cogitClass apiExportHeaderName
			OnFile: (self includeFilePathFor: cogitClass apiExportHeaderName)]
]

{ #category : 'generate sources' }
VMMaker >> generateCogitIncludeFileFor: cogitClass [
	"Generate the skeletal cogit.c that includes the processor-specific cogit files."

	| code fileName file fileCode |
	code := cogitClass generateCodeStringForCogitDotC.
	fileName := (self coreVMDirectory / cogitClass sourceFileName) fullName.
	((self coreVMDirectory asFileReference / cogitClass sourceFileName) exists
	and: [fileCode := fileName asFileReference contents.
		(fileCode allButFirst: (fileCode indexOf: $#)) = (code allButFirst: (code indexOf: $#))]) ifFalse:
		[file := self class forceNewFileNamed: fileName.
		 [file nextPutAll: code] ensure:
			[file close]]
]

{ #category : 'generate sources' }
VMMaker >> generateEntire [
	"Generate the interp, internal plugins and exports as well as the external plugins.
	 If this comes from a generator method, log it for convenience."
	abortBlock := [^self].
	self logGeneration.
	self generateMainVM.
	self generateExternalPlugins
]

{ #category : 'exports' }
VMMaker >> generateExportsFile [
	"Store the exports on the given file"
	| cg contents filePath fileStream |
	filePath := self interpreterExportsFilePath.
	"don't bother endlessly regenerating the example file."
	(internalPlugins isEmpty
	 and: [(filePath includesSubstring: 'example')
	 and: [filePath asFileReference exists]]) ifTrue:
		[^self].
	cg := self createCodeGenerator.
	cg vmClass: self interpreterClass.
	contents := String streamContents:
		[:s|
		s
			nextPutAll:'/* This is an automatically generated table of all builtin modules in the VM';
			cr;
			next: 3 put: Character space;
			nextPutAll: (cg shortMonticelloDescriptionForClass: cg vmClass);
			cr;
			nextPutAll:' */';
			cr.
		s cr; nextPutAll:'extern sqExport vm_exports[];'.
		s cr; nextPutAll: 'extern sqExport os_exports[];'.
		self internalPluginsDo:[:cls|
			s cr; nextPutAll: 'extern sqExport '; nextPutAll: cls moduleName; nextPutAll:'_exports[];'.
		].
		s cr.

		s cr; nextPutAll:'sqExport *pluginExports[] = {'.
		s newLine; tab; nextPutAll:'vm_exports,'.
		s newLine; tab; nextPutAll: 'os_exports,'.
		self internalPluginsDo:[:cls|
			s newLine; tab; nextPutAll: cls moduleName; nextPutAll:'_exports,'
		].
		s newLine; tab; nextPutAll:'NULL'.
		s cr; nextPutAll:'};'; cr].
	(cg needToGenerateHeader: (filePath asFileReference basename) file: filePath contents: contents) ifTrue:
		[[fileStream := VMMaker forceNewFileNamed: filePath] 
			on: FileDoesNotExistException 
			do:[^self couldNotOpenFile: filePath].
		 fileStream nextPutAll: contents; close]
]

{ #category : 'generate sources' }
VMMaker >> generateExternalPlugin: pluginName [ 
	"generate the named external plugin"
	| exports plugin |

	"Refuse to translate this plugin if it requires platform specific files and they are not present."
	[plugin := self validateExternalPlugin: pluginName]
		on: VMMakerException
		do: [:ex|
			logger show: 'external plugin ' , plugin name , ' failed to validate: ' , ex messageText; cr.
			^self].

	vmmakerConfiguration initializeForPlugins: optionsDictionary.
	[exports := plugin
					translateInDirectory: (self externalPluginsDirectoryFor: plugin)
					doInlining: inline]
		on:  ProvideAnswerNotification
		do: [:ex|
			ex tag == #logger
				ifTrue: [ex resume: logger]
				ifFalse: [ex pass]].
	exports ifNotNil: "if exp is nil we skip this since the plugin was already up to date"
		[logger show: 'external plugin ' , plugin name , ' generated as ' , plugin moduleName; cr.
		 self export: exports forExternalPlugin: plugin.
		 self processFilesForExternalPlugin: plugin]
]

{ #category : 'generate sources' }
VMMaker >> generateExternalPlugins [
	"generate the external plugins"

	self logDateAndTime.
	self deleteUnwantedExternalPluginDirectories.
	self vmmakerConfiguration interpreterPluginClass initialize.
	self externalPluginsDo: [:plugin | 
		self generateExternalPlugin: plugin].
	self storeExternalPluginList.
	self logDateAndTime
]

{ #category : 'generate sources' }
VMMaker >> generateInternalPlugin: pluginName [ 
	"generate the named internal plugin. Make sure the exports list is actually 
	correct and write it out"
	self deleteUnwantedInternalPluginDirectories.
	self privateGenerateInternalPlugin: pluginName.
	self generateExportsFile.
	self logDateAndTime
]

{ #category : 'generate sources' }
VMMaker >> generateInternalPlugins [
	"generate the internal plugins and add their exports to the main list. te exports list is NOT written to file by this method"

	self deleteUnwantedInternalPluginDirectories.
	self vmmakerConfiguration interpreterPluginClass initialize.
	self internalPluginsDo: [:plugin | 
		self privateGenerateInternalPlugin: plugin].
	self logDateAndTime.
	self storeInternalPluginList.
]

{ #category : 'generate sources' }
VMMaker >> generateInterpreterFile [
	"Translate the Smalltalk description of the virtual machine into C.  If 'self doInlining' is true, small method bodies are inlined to reduce procedure call overhead.  On the PPC, this results in a factor of three speedup with only 30% increase in code size.  Subclasses can use specialised versions of CCodeGenerator and interpreterClass."

	| cg vmHeaderContents |
	cg := self buildCodeGeneratorForInterpreter.
	self reinitializeWordSizeFrom: cg.

	self generateAdditionalHeadersFor: self interpreterClass withCodeGenerator: cg.

	self needsToRegenerateInterpreterFile ifFalse: [^nil].

	cg inferTypes.

	self interpreterClass preGenerationHook: cg.
	vmHeaderContents := cg vmHeaderContentsWithBytesPerWord: self wordSize.
	(cg needToGenerateHeader: self interpreterHeaderName file: self interpreterHeaderPath contents: vmHeaderContents) ifTrue:
		[cg storeHeaderOnFile: self interpreterHeaderPath contents: vmHeaderContents].
	cg storeCodeOnFile: (self sourceFilePathFor: self interpreterClass sourceFileName) doInlining: self doInlining.
	self interpreterClass apiExportHeaderName ifNotNil:
		[cg storeAPIExportHeader: self interpreterClass apiExportHeaderName
			OnFile: (self includeFilePathFor: self interpreterClass apiExportHeaderName)].
	self gnuifyInterpreterFile
]

{ #category : 'generate sources' }
VMMaker >> generateMainVM [
	"Generate the interp (and optionally the cogit), internal plugins and exports.
	 N.B. generateInterpreterFile *must* precede generateCogitFile so that
	 the objectMemory and interpreter classes are initialized before the Cogit
	 code is generated."

	self logDateAndTime;
		generateInterpreterFile;
		generateCogitFiles;
		generateInternalPlugins;
		generateExportsFile;
		logDateAndTime
]

{ #category : 'generate sources' }
VMMaker >> generatePlugins [
	"Generate the ``external'' plugins.
	 If this comes from a generator method, log it for convenience."
	abortBlock := [^self].
	self logGeneration.
	self generateExternalPlugins
]

{ #category : 'processing external files' }
VMMaker >> gnuifyInterpreterFile [
"post-process the interp.c file to make it gcc friendly"
	(Gnuifier on: self coreVMDirectory)
		doCleanupOldFile: doCleanupOldFiles;
		interpreterFilename: self interpreterFilename;
		gnuify.
]

{ #category : 'generate sources' }
VMMaker >> includeFilePathFor: sourceFileName [
	"Answer the fully-qualified path for the generated source file."
	^ self coreVMHeadersDirectory / sourceFileName
]

{ #category : 'initialize' }
VMMaker >> initialize [
	logger := Transcript.
	inline := true.
	forBrowser := false.
	internalPlugins := SortedCollection new.
	externalPlugins := SortedCollection new.
	platformName := 'Cross'.
	is64BitVM := false.
	doCleanupOldFiles := false.
	interpreterClassName := #StackInterpreterPrimitives.
	optionsDictionary := Dictionary newFromPairs: {#BytesPerWord. 4}.
	SlangStructType voidStructTypeCache
]

{ #category : 'initialize' }
VMMaker >> initializeAllPlugins [
	allPlugins := self providedPlugins
]

{ #category : 'initialize' }
VMMaker >> initializeInternal: arrayOfInternalPluginNames external: arrayOfExternalPluginNames [
	"try to set up with the listed internal and external plugins."

	self initialize.

	self internal: arrayOfInternalPluginNames external: arrayOfExternalPluginNames
]

{ #category : 'initialize' }
VMMaker >> internal: arrayOfInternalPluginNames external: arrayOfExternalPluginNames [
	"try to set up with the listed internal and external plugins. Check that they are supportable plugins, reject those that are not - remember that this depends on the platform etc "

	"since we went to some trouble to drop plugins we cannot handle, don't add them now"
	internalPlugins := (self availablePlugins intersection: arrayOfInternalPluginNames) select: [:pl | self canSupportPlugin: pl].
	allPlugins := allPlugins copyWithoutAll: internalPlugins.
	externalPlugins := (allPlugins intersection: arrayOfExternalPluginNames) select: [:pl | self canSupportPlugin: pl ].
	allPlugins := allPlugins copyWithoutAll: externalPlugins.
	
]

{ #category : 'UI access' }
VMMaker >> internalModules [
	^internalPlugins
]

{ #category : 'target directories' }
VMMaker >> internalPluginListName [
	"Answer the filename for the list of internal plugins"

	^'plugins.int'
]

{ #category : 'target directories' }
VMMaker >> internalPluginsDirectory [
	"return the directory for the internal plugins sources"
	|fd|
	fd := self coreVMDirectory directoryNamed: 'intplugins'.
	fd assureExistence.
	^fd
]

{ #category : 'target directories' }
VMMaker >> internalPluginsDirectoryFor: plugin [
	"return the directory for the internal plugin sources"
	|fd|
	fd := self internalPluginsDirectory directoryNamed: plugin moduleName.
	fd assureExistence.
	^fd
]

{ #category : 'plugin lists' }
VMMaker >> internalPluginsDo: aBlock [ 
	"for each class that should be an internal plugin, evaluate aBlock"
	self plugins: internalPlugins do: aBlock
]

{ #category : 'generate sources' }
VMMaker >> interpreterClass [

	^(Smalltalk classNamed: interpreterClassName) ifNotNil:
		[:interpreterClass| interpreterClass translationClass]
]

{ #category : 'generate sources' }
VMMaker >> interpreterClass: aClass [

	interpreterClassName := aClass name asString
]

{ #category : 'generate sources' }
VMMaker >> interpreterClassName [

	^interpreterClassName
]

{ #category : 'generate sources' }
VMMaker >> interpreterExportsFilePath [
	"return the full path for the interpreter exports file"
	^self coreVMHeadersDirectory fullNameFor: 'sqNamedPrims.h'
]

{ #category : 'target directories' }
VMMaker >> interpreterFilename [
	"Answer the filename for the core interpreter.  Default is 'interp.c'."

	^self interpreterClass sourceFileName
]

{ #category : 'target directories' }
VMMaker >> interpreterHeaderName [
	"Answer the filename for the core interpreter header.  Default is 'interp.h'."

	^'interp.h'
]

{ #category : 'generate sources' }
VMMaker >> interpreterHeaderPath [
	"Answer the fully-qualified path for the generated interpreter header file."

	^ self coreVMHeadersDirectory / self interpreterHeaderName
]

{ #category : 'initialize' }
VMMaker >> isFor64BitVM [
"is my flag to make a 64bit pointer model VM?"
	^is64BitVM
]

{ #category : 'UI access' }
VMMaker >> logDateAndTime [
	| now |
	"do it this way since Time now includes milliseconds in some versions."
	now := Time dateAndTimeNow.
	logger print: now first; space; print: now last; cr; flush
]

{ #category : 'generate sources' }
VMMaker >> logGeneration [
	self configurationGeneratorNameOrNil ifNotNil:
		[:generator|
		 logger cr; nextPutAll: (generator selector copyReplaceAll: 'generate' with: '').
		 interpreterClassName ifNotNil:
			[logger space; nextPutAll: (CCodeGenerator shortMonticelloDescriptionForClass: (Smalltalk classNamed: interpreterClassName))].
		 sourceDirName ifNotNil:
			[logger nextPutAll: ' to '; nextPutAll: sourceDirName].
		 logger cr; flush]
]

{ #category : 'UI access' }
VMMaker >> logger [
	^logger
]

{ #category : 'UI access' }
VMMaker >> logger: aStream [
	logger := aStream.
]

{ #category : 'target directories' }
VMMaker >> makefileDirectory [
"where to put generated makefile related files"
	^self sourceDirectory
]

{ #category : 'generate sources' }
VMMaker >> needsToRegenerateCogitFile [
	"Check the timestamp for the relevant classes and then the timestamp for the main source file (e.g. interp.c)
	 file if it already exists. Answer if the file needs regenerating."

	| cogitClass cogitClasses tStamp files |
	cogitClasses := (cogitClass := self interpreterClass cogitClass) withAllSuperclasses copyUpThrough: self vmmakerConfiguration baseCogitClass.
	cogitClasses addAllLast: cogitClass ancilliaryClasses.
	tStamp := cogitClasses inject: 0 into: [:tS :cl| tS max: cl timeStamp].

	"don't translate if the file(s) is newer than my timeStamp"
	files := (self coreVMDirectory children select: [ :e | e basename match: cogitClass activeCompilerClass moduleName, '*.c' ]).

	files isEmpty ifTrue:
		[^true].
	(files allSatisfy:
		[:fileName|
		(self coreVMDirectory entryAt: fileName ifAbsent: [nil])
			ifNil: [false]
			ifNotNil:
				[:fstat| | mTime |
				mTime := fstat modificationTime.
				mTime isInteger ifFalse: [mTime := mTime asSeconds].
				tStamp < mTime]]) ifTrue:
		[^self confirm: ('The ', self configurationNameIfAny, cogitClass printString,
			', ', cogitClass activeCompilerClass, '\classes have not been modified since the ',
			cogitClass processorSpecificSourceFileName,
			' source file\was last generated.  Do you still want to regenerate it?') withCRs].
	^true
]

{ #category : 'initialize' }
VMMaker >> needsToRegenerateInterpreterFile [
	"Check the timestamp for the relevant classes and then the timestamp for the main
	 source file (e.g. interp.c) if it already exists.  Answer if the file needs regenerating."

	| classes tStamp |
	classes := self interpreterClass withAllSuperclasses copyUpTo: SlangClass.
	self interpreterClass objectMemoryClass ifNotNil:
		[:objectMemoryClass|
		classes addAllLast: (objectMemoryClass withAllSuperclasses copyUpTo: SlangClass)].
	classes copy do:
		[:class| classes addAllLast: class ancilliaryClasses].
	tStamp := classes inject: 0 into: [:tS :cl| tS max: cl timeStamp].

	"don't translate if the file is newer than my timeStamp"
	(self coreVMDirectory / self interpreterFilename) ifExists: [ :aFile | | mTime |
		mTime := aFile modificationTime.
		mTime isInteger ifFalse: [mTime := mTime asSeconds].
		tStamp < mTime ifTrue:
			[^self confirm: 'The ', self configurationNameIfAny, 'interpreter classes have not been modified since\ the interpreter file was last generated.\Do you still want to regenerate the source file?' withCRs]].
	^true
]

{ #category : 'accessing' }
VMMaker >> options [
	^optionsDictionary
]

{ #category : 'initialize' }
VMMaker >> options: aDictionary [
	
	optionsDictionary := aDictionary

]

{ #category : 'source directories' }
VMMaker >> platformDirectory [
	"return the directory where we should find the platform specific sources"
	| dir |
	dir := self platformRootDirectory directoryNamed: self platformName.
	dir exists ifFalse: "The supposed directory for the actual platform code does not exist."
		[^self couldNotFindPlatformDirectoryFor: self platformName].
	^dir
]

{ #category : 'UI access' }
VMMaker >> platformName [
	^platformName
]

{ #category : 'source directories' }
VMMaker >> platformPluginsDirectory [
	"return the directory where we should find the platform plugin specific sources"

	| dir |
	dir := self platformDirectory directoryNamed: self class pluginsDirName.
	dir exists ifFalse: "The supposed directory for the plugins code does not exist.
					   We need to raise a suitable exception, but can't think of one right now."
		[^self couldNotFindPlatformDirectoryFor: 'any plugins needing ', self platformName].
	^dir
]

{ #category : 'source directories' }
VMMaker >> platformRootDirectory [
	"Answer the directory where we should find all platform's sources"
	| dir |
	dir := self platformRootDirectoryName asFileReference.
	dir exists ifFalse: "The supposed directory for the platforms code does not exist."
		 [^self couldNotFindDirectory: 'the platform code tree'].
	^dir
]

{ #category : 'source directories' }
VMMaker >> platformRootDirectoryName [
	"Answer the name of the directory where we should find all platform's sources"
	^platformRootDirName ifNil:
		[self class rootDirectory fullNameFor: self class platformsDirName]
]

{ #category : 'source directories' }
VMMaker >> platformRootDirectoryName: aString [
	"set the directory where we should find all platform's sources
	There really ought to be plausible sanity checks done here"
	platformRootDirName := aString.
	
	aString asFileReference exists 
		ifFalse:[self couldNotFindDirectory: aString. ^false].
	
	self reinitializePluginsLists.
	^true
]

{ #category : 'plugin lists' }
VMMaker >> plugins: aCollection do: aBlock [ 
	"for each class in aCollection that should be a plugin, evaluate aBlock"
	aCollection do: [:sym | (Smalltalk hasClassNamed: sym)
			ifTrue: [aBlock value: (Smalltalk classNamed: sym)]
			ifFalse:["Another place to raise a sensible error to the UI"
				self couldNotFindPluginClass: sym]]
]

{ #category : 'generate sources' }
VMMaker >> privateGenerateInternalPlugin: pluginName [ 
	"generate the named internal plugin"
	| plugin |
	"Refuse translate this plugin if it requires platform specific files and  
	they are not present."
	plugin := self validateInternalPlugin: pluginName.

	plugin ifNil:
		[^self couldNotFindPluginClass: pluginName].
	[plugin
			translateInDirectory: (self internalPluginsDirectoryFor: plugin)
			doInlining: inline]
		on:  ProvideAnswerNotification
		do: [:ex|
			ex tag == #logger
				ifTrue: [ex resume: logger]
				ifFalse: [ex pass]].
	logger show: 'internal plugin ' , plugin name , ' generated as ' , plugin moduleName; cr.
	self processFilesForInternalPlugin: plugin
]

{ #category : 'processing external files' }
VMMaker >> processFilesForExternalPlugin: plugin [ 

]

{ #category : 'processing external files' }
VMMaker >> processFilesForInternalPlugin: plugin [ 

]

{ #category : 'initialize' }
VMMaker >> providedPlugins [
	"generate the list by asking the InterpreterPlugins"
	^ ((self vmmakerConfiguration interpreterPluginClass allSubclasses
		select: [:cl | cl shouldBeTranslatedFor: platformName])
		collect: [:cl | cl name]) asSortedCollection
]

{ #category : 'UI access' }
VMMaker >> reinitializePluginsLists [
	"something has changed that affects the validity of the plugin lists. Recalculate them as best we can. It is probably possible to check on the current lists and keep the configuration as close as possible the same; but for the moment just try to use the same lists "
	self initializeAllPlugins.
	self internal: internalPlugins external: externalPlugins.
	self changed: #reinitialize 
]

{ #category : 'initialize' }
VMMaker >> reinitializeWordSizeFrom: aCCodeGenerator [
	| wordSize |
	wordSize := aCCodeGenerator vmClass objectMemoryClass wordSize.
	optionsDictionary at: #BytesPerWord put: wordSize.
	is64BitVM := wordSize = 8
]

{ #category : 'initialize' }
VMMaker >> setPlatName: aString [
	"private - just set the platform name string, nothing else. Go away...."
	platformName := aString
]

{ #category : 'target directories' }
VMMaker >> sourceDirectory [

	^ self sourceDirectoryName asFileReference
		  ensureCreateDirectory;
		  yourself
]

{ #category : 'target directories' }
VMMaker >> sourceDirectoryName [
	^sourceDirName ifNil:
		[self class rootDirectory fullNameFor: self class sourceDirName]
]

{ #category : 'target directories' }
VMMaker >> sourceDirectoryName: aString [
	"Sanity check really ought to be added, This is the root directory for where the sources will be WRITTEN"
	sourceDirName := aString.
	
	sourceDirName asFileReference ensureCreateDirectory.

	self changed: #sourceDirectory.
	^true
]

{ #category : 'generate sources' }
VMMaker >> sourceFilePathFor: sourceFileName [
	"Answer the fully-qualified path for the generated source file."
	^ self coreVMDirectory / sourceFileName
]

{ #category : 'accessing' }
VMMaker >> stopOnErrors: aValue [

	stopOnErrors := aValue
]

{ #category : 'exports' }
VMMaker >> storeExternalPluginList [
	| contents filePath fileStream |
	((self externalPluginListName beginsWith: 'example')
	 and: [(self makefileDirectory asFileReference / self externalPluginListName) exists]) ifTrue:
		[^self].
	contents := String streamContents:
		[:s|
		s nextPutAll:'# Automatically generated makefile include for external plugins'.
		s cr; nextPutAll:'EXTERNAL_PLUGINS ='.
		self externalPluginsDo:
			[:cls|
			s space; nextPut: $\; cr; nextPutAll: cls moduleName].
		s cr].
	filePath := (self makefileDirectory / self externalPluginListName) fullName.
	(CCodeGenerator basicNew needToGenerateHeader: filePath file: filePath contents: contents) ifTrue:
		[[fileStream := VMMaker forceNewFileNamed: filePath] 
			on: FileDoesNotExistException 
			do:[^self couldNotOpenFile: filePath].
		 fileStream nextPutAll: contents; close]
]

{ #category : 'exports' }
VMMaker >> storeInternalPluginList [
	| contents filePath fileStream |
	((self internalPluginListName beginsWith: 'example')
	 and: [(self makefileDirectory asFileReference / self internalPluginListName) exists]) ifTrue:
		[^self].
	contents := String streamContents:
		[:s|
		s nextPutAll:'# Automatically generated makefile include for internal plugins'.
		s cr; nextPutAll:'INTERNAL_PLUGINS ='.
		self internalPluginsDo:
			[:cls|
			s space; nextPut: $\; cr; nextPutAll: cls moduleName].
		s cr].
	filePath := self makefileDirectory fullNameFor: self internalPluginListName.
	(CCodeGenerator basicNew needToGenerateHeader: filePath file: filePath contents: contents) ifTrue:
		[[fileStream := VMMaker forceNewFileNamed: filePath] 
			on: FileDoesNotExistException 
			do:[^self couldNotOpenFile: filePath].
		 fileStream nextPutAll: contents; close]
]

{ #category : 'generate sources' }
VMMaker >> validateExternalPlugin:	plName [

	^self validatePlugin: plName in: externalPlugins
]

{ #category : 'generate sources' }
VMMaker >> validateInternalPlugin:	plName [

	^self validatePlugin: plName in: internalPlugins
]

{ #category : 'generate sources' }
VMMaker >> validatePlugin:	plName in: listOfPlugins [
"check that the plName is either an actual plugin class or a plugin class name. Return the plugin class or raise an error if nil"
	| plugin |
	plName isString
		ifTrue: [(listOfPlugins includes: plName)
				ifTrue: [plugin := Smalltalk classNamed: plName]]
		ifFalse: [((plName isBehavior
						and: [plName inheritsFrom: self vmmakerConfiguration interpreterPluginClass])
					and: [listOfPlugins includes: plName name])
				ifTrue: [plugin := plName]].
	plugin ifNil: [^ self couldNotFindPluginClass: plName].

	"Is there a cross-platform or platform files directory of the same name as this plugin?"
	plugin requiresPlatformFiles
		ifTrue: [(self platformPluginsDirectory directoryExists: plugin moduleName)
				ifFalse: [logger show: 'No platform specific files found for ' , plugin moduleName printString; cr.
					^ self couldNotFindPlatformFilesFor: plugin]].
	plugin requiresCrossPlatformFiles
		ifTrue: [(self crossPlatformPluginsDirectory directoryExists: plugin moduleName)
				ifFalse: [logger show: 'No cross platform files found for ' , plugin moduleName printString; cr.
					^ self couldNotFindPlatformFilesFor: plugin]].

	^plugin
]

{ #category : 'accessing' }
VMMaker >> vmmakerConfiguration [
	
	^ vmmakerConfiguration
]

{ #category : 'accessing' }
VMMaker >> vmmakerConfiguration: aClass [ 
	vmmakerConfiguration := aClass
]

{ #category : 'initialize' }
VMMaker >> wordSize [
	"Return the bytes in a word for the chosen 32bit/64bit pointer setup chosen"
	^is64BitVM ifTrue:[8] ifFalse:[4]
]
